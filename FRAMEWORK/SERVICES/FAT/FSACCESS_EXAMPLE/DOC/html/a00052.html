<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AVR32 UC3 - FSACCESS Services: fat_unusual.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>fat_unusual.c</h1><a href="a00021.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*This file has been prepared for Doxygen automatic documentation generation.*/</span>
<a name="l00014"></a>00014 <span class="comment">/* Copyright (c) 2009 Atmel Corporation. All rights reserved.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00017"></a>00017 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice, this</span>
<a name="l00020"></a>00020 <span class="comment"> * list of conditions and the following disclaimer.</span>
<a name="l00021"></a>00021 <span class="comment"> *</span>
<a name="l00022"></a>00022 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<a name="l00023"></a>00023 <span class="comment"> * this list of conditions and the following disclaimer in the documentation</span>
<a name="l00024"></a>00024 <span class="comment"> * and/or other materials provided with the distribution.</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> * 3. The name of Atmel may not be used to endorse or promote products derived</span>
<a name="l00027"></a>00027 <span class="comment"> * from this software without specific prior written permission.</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> * 4. This software may only be redistributed and used in connection with an Atmel</span>
<a name="l00030"></a>00030 <span class="comment"> * AVR product.</span>
<a name="l00031"></a>00031 <span class="comment"> *</span>
<a name="l00032"></a>00032 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED</span>
<a name="l00033"></a>00033 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<a name="l00034"></a>00034 <span class="comment"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE</span>
<a name="l00035"></a>00035 <span class="comment"> * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR</span>
<a name="l00036"></a>00036 <span class="comment"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<a name="l00037"></a>00037 <span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<a name="l00038"></a>00038 <span class="comment"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<a name="l00039"></a>00039 <span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00040"></a>00040 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00041"></a>00041 <span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</span>
<a name="l00042"></a>00042 <span class="comment"> *</span>
<a name="l00043"></a>00043 <span class="comment"> */</span>
<a name="l00044"></a>00044 <span class="comment">//_____  I N C L U D E S ___________________________________________________</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include "<a class="code" href="a00016.html" title="FAT configuration file.">conf_explorer.h</a>"</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include "<a class="code" href="a00024.html" title="FAT 12/16/32 Services.">fs_com.h</a>"</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include "<a class="code" href="a00020.html" title="FAT services.">fat.h</a>"</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include LIB_MEM</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#include LIB_CTRLACCESS</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">//_____ D E F I N I T I O N S ______________________________________________</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">//_____ D E C L A R A T I O N S ____________________________________________</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 Bool  <a class="code" href="a00021.html#477e90a97f3fcb8361020feb2557098d" title="This function computes the FAT type to use.">fat_select_filesystem</a>               ( U8 u8_fat_type , Bool b_MBR );
<a name="l00060"></a>00060 Bool  <a class="code" href="a00021.html#9075855486dc53d38dd64e068b512027" title="This function writes the MBR.">fat_write_MBR</a>                       ( <span class="keywordtype">void</span> );
<a name="l00061"></a>00061 Bool  <a class="code" href="a00021.html#89d56497bd58d7d6553b7e319f3ee863" title="This function writes the PBR.">fat_write_PBR</a>                       ( Bool b_MBR );
<a name="l00062"></a>00062 Bool  <a class="code" href="a00021.html#ad6177926c645c867ea1d23c727d9097" title="This function cleans the reserved zone, FAT zone, and root dir zone.">fat_clean_zone</a>                      ( Bool b_MBR );
<a name="l00063"></a>00063 Bool  <a class="code" href="a00021.html#6ab74fa9e68a4379a3ea33465d835277" title="This function initializes the fat one and two.">fat_initialize_fat</a>                  ( <span class="keywordtype">void</span> );
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 
<a name="l00068"></a>00068 <span class="keywordtype">void</span>  <a class="code" href="a00021.html#015e44f70b92d8b39e00ababfdb6bc24" title="This function translates a date FAT value to ascii string.">fat_translatedate_number_to_ascii</a>   ( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_date , <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_date , Bool enable_ms );
<a name="l00069"></a>00069 <span class="keywordtype">void</span>  <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>       ( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_ascii_number, U8 u8_size_number_ascii, U8 u8_nb_increment );
<a name="l00070"></a>00070 <span class="keywordtype">void</span>  <a class="code" href="a00021.html#f2d2b930b3953ad1cfc996de5970a138" title="This function translates a date ascii string to date FAT value.">fat_translatedate_ascii_to_number</a>   ( <span class="keyword">const</span> <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_date , <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_date , Bool enable_ms );
<a name="l00071"></a>00071 U16   <a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>       ( <span class="keyword">const</span> <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_ascii_number, U8 u8_size_number_ascii  );
<a name="l00073"></a>00073 
<a name="l00076"></a>00076 <span class="keywordtype">void</span>  <a class="code" href="a00021.html#70a6be69645d22685e0ec6b52b93d9b2" title="This function creates a long name entry.">fat_create_long_name_entry</a>          ( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_name , U8 u8_crc , U8 u8_id  );
<a name="l00077"></a>00077 U8    <a class="code" href="a00021.html#49163f06665633236c432aa1a1163f01" title="This function creates a short name in the internal cache sector OR in a string.">fat_create_short_entry_name</a>         ( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_name , <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> short_name , U8 nb , Bool mode  );
<a name="l00078"></a>00078 U8    <a class="code" href="a00021.html#24d01b29254a31c7b331935fd8288037" title="This function searchs an unique short name.">fat_find_short_entry_name</a>           ( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_name  );
<a name="l00079"></a>00079 Bool  <a class="code" href="a00021.html#19c7a66123aba4a4a705623085c03f6f" title="This function compares a short name with the current entry.">fat_entry_shortname_compare</a>         ( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> short_name );
<a name="l00080"></a>00080 U8    <a class="code" href="a00021.html#8849a8388de3f116fd53fd9ec07747b2" title="This function checks the character in name AND computes the number of entry file...">fat_check_name</a>                      ( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_name  );
<a name="l00081"></a>00081 U8    <a class="code" href="a00021.html#bb2561113110b35fac032431243f8bb0" title="This function translates the character to autorized short name character.">fat_translate_char_shortname</a>        ( U8 character );
<a name="l00082"></a>00082 Bool  <a class="code" href="a00021.html#a2b4dadfd961b4547fd67f7ebe8a5c5d" title="This function allocs a number of entry in a current directory.">fat_alloc_entry_free</a>                ( U8 u8_nb_entry );
<a name="l00083"></a>00083 Bool  <a class="code" href="a00021.html#865edc51b046f0bfc2b1e6d270ed5ac0" title="This function remove the entry delected in the directory to clean it.">fat_garbage_collector_entry</a>         ( <span class="keywordtype">void</span> );
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 
<a name="l00105"></a><a class="code" href="a00021.html#c0108ea608b547e8d3a405c70644c1e9">00105</a> Bool  <a class="code" href="a00020.html#c0108ea608b547e8d3a405c70644c1e9" title="This function mounts a partition.">fat_mount</a>( <span class="keywordtype">void</span> )
<a name="l00106"></a>00106 {
<a name="l00107"></a>00107    U8  u8_sector_size;
<a name="l00108"></a>00108    U8  u8_tmp;
<a name="l00109"></a>00109    U16 u16_tmp;
<a name="l00110"></a>00110    U32 u32_tmp;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112    <span class="comment">// Select the root directory</span>
<a name="l00113"></a>00113    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f" title="First cluster number of selected directory (0 for the root directory).">u32_cluster_sel_dir</a>   = 0;
<a name="l00114"></a>00114    <span class="comment">// No selected file</span>
<a name="l00115"></a>00115    <a class="code" href="a00019.html#56d9a210bc2d4b0b5c46cb24a2e9f690" title="This function resets the selection pointers.">fat_clear_entry_info_and_ptr</a>();
<a name="l00116"></a>00116 
<a name="l00117"></a>00117    <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920" title="FAT type (default = no mounted = FS_TYPE_FAT_UNM).">u8_type_fat</a> = <a class="code" href="a00020.html#429fbd0498704c3d5864877548040069" title="Partition not mounted.">FS_TYPE_FAT_UNM</a>;
<a name="l00118"></a>00118    <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = 0;    <span class="comment">// Start read at the beginning of memory</span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120    <span class="comment">// Check if the drive is availabled</span>
<a name="l00121"></a>00121    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#eeec0bd6755a6be4c4dda2b4669eb0ae" title="This function checks device state.">fat_check_device</a>() )
<a name="l00122"></a>00122       <span class="keywordflow">return</span> FALSE;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124    <span class="keywordflow">while</span>( 1 )  <span class="comment">// Search a valid partition</span>
<a name="l00125"></a>00125    {
<a name="l00126"></a>00126       <span class="comment">// Read one sector</span>
<a name="l00127"></a>00127       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( TRUE ))
<a name="l00128"></a>00128          <span class="keywordflow">return</span> FALSE;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130       <span class="comment">// Check PBR/MBR signature</span>
<a name="l00131"></a>00131       <span class="keywordflow">if</span> ( (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[510] != <a class="code" href="a00020.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a>  )
<a name="l00132"></a>00132       &amp;&amp;   (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[511] != <a class="code" href="a00020.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a> ) )
<a name="l00133"></a>00133       {
<a name="l00134"></a>00134          <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#34de358c4f6461ed5f3f199fd5cb679f" title="The selected drive isn&amp;#39;t formated.">FS_ERR_NO_FORMAT</a>;
<a name="l00135"></a>00135          <span class="keywordflow">return</span> FALSE;
<a name="l00136"></a>00136       }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138       <span class="keywordflow">if</span> ( 0 == <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> )
<a name="l00139"></a>00139       {
<a name="l00140"></a>00140          <span class="comment">//** first sector then check a MBR structure</span>
<a name="l00141"></a>00141          <span class="comment">// Search the first partition supported</span>
<a name="l00142"></a>00142 <span class="preprocessor">#if (FS_MULTI_PARTITION == ENABLED)</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span>         u16_tmp=0;  <span class="comment">// Init to "no valid partition found"</span>
<a name="l00144"></a>00144 <span class="preprocessor">#endif</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span>         <span class="keywordflow">for</span>( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
<a name="l00146"></a>00146          {
<a name="l00147"></a>00147             <span class="comment">// The first sector must be a MBR, then check the partition entry in the MBR</span>
<a name="l00148"></a>00148             <span class="keywordflow">if</span> ( ((<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+0] == <a class="code" href="a00020.html#b01eb16ba36dc7c0412a886c1678232f">FS_PART_BOOTABLE</a>             )||
<a name="l00149"></a>00149                   (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+0] == <a class="code" href="a00020.html#e9933a03e28f302f391f377b8efc001d">FS_PART_NO_BOOTABLE</a>          )  )
<a name="l00150"></a>00150             &amp;&amp;   ((<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00020.html#d8702ceb3912c09278602d3ea33224ff">FS_PART_TYPE_FAT12</a>           )||
<a name="l00151"></a>00151                   (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00020.html#b9f13193999f7bb7ea0e4be6cf5ee57b">FS_PART_TYPE_FAT16_INF32M</a>    )||
<a name="l00152"></a>00152                   (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00020.html#29856400974fc942f9cf900a44ea7389">FS_PART_TYPE_FAT16_SUP32M</a>    )||
<a name="l00153"></a>00153                   (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00020.html#c7c65caf9513f8cddd4319b334813d85">FS_PART_TYPE_FAT16_SUP32M_BIS</a>)||
<a name="l00154"></a>00154                   (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00020.html#93881dd293ba41286e413bef3212786a">FS_PART_TYPE_FAT32</a>           )||
<a name="l00155"></a>00155                   (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+4] == <a class="code" href="a00020.html#3e13e837536764161f0aa9768e76b2e1">FS_PART_TYPE_FAT32_BIS</a>       )) )
<a name="l00156"></a>00156             {
<a name="l00157"></a>00157                <span class="comment">// A valid partition is found</span>
<a name="l00158"></a>00158 <span class="preprocessor">#if (FS_MULTI_PARTITION == ENABLED)</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>               <span class="keywordflow">if</span>( u16_tmp == <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af482bc02a186c363c37c93e169fbbd4" title="Number of partition - 1 (0 or 1).">u8_partition</a> )
<a name="l00160"></a>00160                   <span class="keywordflow">break</span>;   <span class="comment">// The selected partition is valid</span>
<a name="l00161"></a>00161                u16_tmp++;
<a name="l00162"></a>00162 <span class="preprocessor">#else</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span>               <span class="keywordflow">break</span>;
<a name="l00164"></a>00164 <span class="preprocessor">#endif</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>            }
<a name="l00166"></a>00166          }
<a name="l00167"></a>00167          <span class="keywordflow">if</span>( u8_tmp != 4 )
<a name="l00168"></a>00168          {
<a name="l00169"></a>00169             <span class="comment">// Partition found -&gt; Get partition position (unit sector) at offset 8</span>
<a name="l00170"></a>00170             LSB0(<a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>) = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+8];
<a name="l00171"></a>00171             LSB1(<a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>) = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+9];
<a name="l00172"></a>00172             LSB2(<a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>) = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+10];
<a name="l00173"></a>00173             LSB3(<a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>) = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(u8_tmp)+11];
<a name="l00174"></a>00174             <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> *= <a class="code" href="a00017.html#6f34e66828041ff96e8bc09efa5a4bec" title="Returns the size of the physical sector.">mem_sector_size</a>( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#43065262a1a7560b143e0b48cbf5ccbd" title="Number of logical driver.">u8_lun</a> );
<a name="l00175"></a>00175             <span class="keywordflow">continue</span>;   <span class="comment">// Go to check PBR of partition</span>
<a name="l00176"></a>00176          }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178          <span class="comment">// No MBR found then check PBR</span>
<a name="l00179"></a>00179 <span class="preprocessor">#if (FS_MULTI_PARTITION == ENABLED)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>         <span class="comment">// The device don't have mutli partition, but only one</span>
<a name="l00181"></a>00181          <span class="keywordflow">if</span> ( 0 != <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af482bc02a186c363c37c93e169fbbd4" title="Number of partition - 1 (0 or 1).">u8_partition</a> )
<a name="l00182"></a>00182          {
<a name="l00183"></a>00183             <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#bf3770f49c4ecabdec290f9238f4a906" title="The selected partition doesn&amp;#39;t existed.">FS_ERR_NO_PART</a>;
<a name="l00184"></a>00184             <span class="keywordflow">return</span> FALSE;
<a name="l00185"></a>00185          }
<a name="l00186"></a>00186 <span class="preprocessor">#endif</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>      }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189       <span class="comment">//** Check a PBR structure</span>
<a name="l00190"></a>00190       <span class="keywordflow">if</span> ( (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[0] == 0xEB) &amp;&amp;          <span class="comment">// PBR Byte 0</span>
<a name="l00191"></a>00191            (<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[2] == 0x90) &amp;&amp;          <span class="comment">// PBR Byte 2</span>
<a name="l00192"></a>00192            ((<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[21] &amp; 0xF0) == 0xF0) ) <span class="comment">// PBR Byte 21 : Media byte</span>
<a name="l00193"></a>00193       {
<a name="l00194"></a>00194          <span class="keywordflow">break</span>;   <span class="comment">// valid PBR found</span>
<a name="l00195"></a>00195       }
<a name="l00196"></a>00196       <span class="comment">// PBR not found</span>
<a name="l00197"></a>00197       <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#bf3770f49c4ecabdec290f9238f4a906" title="The selected partition doesn&amp;#39;t existed.">FS_ERR_NO_PART</a>;
<a name="l00198"></a>00198       <span class="keywordflow">return</span> FALSE;
<a name="l00199"></a>00199    }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201    <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#76bd560138ff87de29b59767546d8bf3" title="The selected partition isn&amp;#39;t supported.">FS_ERR_NO_SUPPORT_PART</a>;  <span class="comment">// by default partition no supported</span>
<a name="l00202"></a>00202 
<a name="l00203"></a>00203    <span class="comment">// Get sector size of File System (unit 512B)</span>
<a name="l00204"></a>00204    <span class="comment">// To translate from sector disk unit to sector 512B unit</span>
<a name="l00205"></a>00205    u8_sector_size = <a class="code" href="a00020.html#1bf0f3b3cb79deb5b7c459b5d10449d5">HIGH_16_BPB_BytsPerSec</a>/2;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207    <span class="comment">// Read BPB_SecPerClus (unit sector)</span>
<a name="l00208"></a>00208    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a> = <a class="code" href="a00020.html#14c055fd6f5b4bda4470668bab3694ee">U8_BPB_SecPerClus</a> * u8_sector_size;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210    <span class="comment">//** FAT Type determination (algorithm of "Hardware White Paper FAT")</span>
<a name="l00211"></a>00211    <span class="comment">// Get FAT size (unit sector)</span>
<a name="l00212"></a>00212    LSB( u16_tmp ) = <a class="code" href="a00020.html#fe57e984b2baf3970ac7feda02355ac9">LOW_16_BPB_FATSz16</a>;
<a name="l00213"></a>00213    MSB( u16_tmp ) = <a class="code" href="a00020.html#c7277af1ce6ee4efe860da2d1f3b1b38">HIGH_16_BPB_FATSz16</a>;
<a name="l00214"></a>00214    <span class="keywordflow">if</span> ( 0==u16_tmp )
<a name="l00215"></a>00215    {
<a name="l00216"></a>00216       LSB( u16_tmp ) = <a class="code" href="a00020.html#c1ba95f06dfaaf3c71a5eb12dd56009c">LOW0_32_BPB_FATSz32</a>;
<a name="l00217"></a>00217       MSB( u16_tmp ) = <a class="code" href="a00020.html#dff814b0d106b4c3b3f730fbef8338ce">LOW1_32_BPB_FATSz32</a>;
<a name="l00218"></a>00218       <span class="comment">// a large FAT32 isn't supported by this file system</span>
<a name="l00219"></a>00219       <span class="keywordflow">if</span>( (0 != <a class="code" href="a00020.html#8ef0e71139f216c7aaa15dc92f04ad74">LOW2_32_BPB_FATSz32</a> )
<a name="l00220"></a>00220       ||  (0 != <a class="code" href="a00020.html#ae445a7061c79d078f70001aa7d5ca16">LOW3_32_BPB_FATSz32</a> ) )
<a name="l00221"></a>00221       {
<a name="l00222"></a>00222          <span class="keywordflow">return</span> FALSE;
<a name="l00223"></a>00223       }
<a name="l00224"></a>00224    }
<a name="l00225"></a>00225    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a> = u16_tmp * u8_sector_size;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227    <span class="comment">// Get total count of sectors in partition</span>
<a name="l00228"></a>00228    <span class="keywordflow">if</span> ( (0==<a class="code" href="a00020.html#b63400ba470fe3bf6c110a0af483ccc0">LOW_16_BPB_TotSec16</a>) &amp;&amp; (0==<a class="code" href="a00020.html#3f384bfdb0b306957dbc5f9c9b087dbe">HIGH_16_BPB_TotSec16</a>) )
<a name="l00229"></a>00229    {
<a name="l00230"></a>00230       LSB0( u32_tmp ) = <a class="code" href="a00020.html#874e06185fcba59848db370a65ffb162">LOW0_32_BPB_TotSec32</a>;
<a name="l00231"></a>00231       LSB1( u32_tmp ) = <a class="code" href="a00020.html#36c744b34bb704e3777d34a3b4c365a7">LOW1_32_BPB_TotSec32</a>;
<a name="l00232"></a>00232       LSB2( u32_tmp ) = <a class="code" href="a00020.html#b1bff622ef1d89f52b64b80e0f04bb4c">LOW2_32_BPB_TotSec32</a>;
<a name="l00233"></a>00233       LSB3( u32_tmp ) = <a class="code" href="a00020.html#f6bd554441216cd3475dd35a23d2a282">LOW3_32_BPB_TotSec32</a>;
<a name="l00234"></a>00234    }
<a name="l00235"></a>00235    <span class="keywordflow">else</span>
<a name="l00236"></a>00236    {
<a name="l00237"></a>00237       LSB0( u32_tmp ) = <a class="code" href="a00020.html#b63400ba470fe3bf6c110a0af483ccc0">LOW_16_BPB_TotSec16</a>;
<a name="l00238"></a>00238       LSB1( u32_tmp ) = <a class="code" href="a00020.html#3f384bfdb0b306957dbc5f9c9b087dbe">HIGH_16_BPB_TotSec16</a>;
<a name="l00239"></a>00239       LSB2( u32_tmp ) = 0;
<a name="l00240"></a>00240       LSB3( u32_tmp ) = 0;
<a name="l00241"></a>00241    }
<a name="l00242"></a>00242    u32_tmp *= u8_sector_size;   <span class="comment">// Translate from sector disk unit to sector 512B unit</span>
<a name="l00243"></a>00243 
<a name="l00244"></a>00244    <span class="comment">// Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR</span>
<a name="l00245"></a>00245    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428" title="For FAT 12 &amp;amp; 16, it is a segment (no cluster list).">seg</a>.<a class="code" href="a00007.html#a17ca07269fcb28d77b14e5a67d56378" title="Offset between the beginning of FAT and the beginning of root dir (unit 512B).">u16_pos</a> = <a class="code" href="a00020.html#4d46dee315ad22b94de647e7c883edc0">FS_NB_FAT</a> * <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247    <span class="comment">// Compute the root directory size (unit sector), for FAT32 is always 0</span>
<a name="l00248"></a>00248    LSB( u16_tmp ) = <a class="code" href="a00020.html#b1eab4cea0637f0fa8c7e521968803a2">LOW_16_BPB_RootEntCnt</a>;
<a name="l00249"></a>00249    MSB( u16_tmp ) = <a class="code" href="a00020.html#8f6e516573fdbd3ea8eadd402cc6e134">HIGH_16_BPB_RootEntCnt</a>;
<a name="l00250"></a>00250    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428" title="For FAT 12 &amp;amp; 16, it is a segment (no cluster list).">seg</a>.<a class="code" href="a00007.html#5e384bddb7393218e17f0329d1b8527f" title="Size of root (unit 512B).">u16_size</a> = ((u16_tmp * <a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>) + ((<a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a>*u8_sector_size)-1)) / (<a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a>*u8_sector_size);
<a name="l00251"></a>00251    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428" title="For FAT 12 &amp;amp; 16, it is a segment (no cluster list).">seg</a>.<a class="code" href="a00007.html#5e384bddb7393218e17f0329d1b8527f" title="Size of root (unit 512B).">u16_size</a> *= u8_sector_size;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253    <span class="comment">// Get number of reserved sector</span>
<a name="l00254"></a>00254    LSB( u16_tmp ) = <a class="code" href="a00020.html#054eca177d5b03154cb95ead9e3cca0b">LOW_16_BPB_ResvSecCnt</a>;
<a name="l00255"></a>00255    MSB( u16_tmp ) = <a class="code" href="a00020.html#72679a68a6d92475a790f11861a92316">HIGH_16_BPB_ResvSecCnt</a>;
<a name="l00256"></a>00256    <span class="comment">// Get FSInfo position</span>
<a name="l00257"></a>00257    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#d7fc62fd6868a846c0f242c6cf35fe60" title="Offset between the beginning of FAT and the FSInfo sector (only used by FAT32) (unit...">u16_offset_FSInfo</a> = (u16_tmp-<a class="code" href="a00020.html#690460cf97d7336c73da86955724b060">LOW_16_BPB_FSInfo</a>)*u8_sector_size;
<a name="l00258"></a>00258    u16_tmp *= u8_sector_size; <span class="comment">// number of reserved sector translated in unit 512B</span>
<a name="l00259"></a>00259 
<a name="l00260"></a>00260    <span class="comment">// Compute the FAT address (unit 512B)</span>
<a name="l00261"></a>00261    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> = <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> + u16_tmp;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263    <span class="comment">// Compute the offset (unit 512B) between the first data cluster and the FAT beginning</span>
<a name="l00264"></a>00264    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#4666662ac4fa96c340a61e5fb786b83a" title="Offset between the beginning of FAT and the first cluster (unit 512B).">u32_offset_data</a> = (<a class="code" href="a00020.html#4d46dee315ad22b94de647e7c883edc0">FS_NB_FAT</a> * (U32)<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>) + (U32)<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#996b5fc79b7527c2b3dc3b34ed98f428" title="For FAT 12 &amp;amp; 16, it is a segment (no cluster list).">seg</a>.<a class="code" href="a00007.html#5e384bddb7393218e17f0329d1b8527f" title="Size of root (unit 512B).">u16_size</a>;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266    <span class="comment">// Compute the data region (clusters space = Total - Sector used) size (unit 512B)</span>
<a name="l00267"></a>00267    u32_tmp -= ((U32)u16_tmp + <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#4666662ac4fa96c340a61e5fb786b83a" title="Offset between the beginning of FAT and the first cluster (unit 512B).">u32_offset_data</a>);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269    <span class="comment">// Compute the count of CLUSTER in the data region</span>
<a name="l00270"></a>00270    <span class="comment">// !!!Optimization -&gt; u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B &amp; power of 2)</span>
<a name="l00271"></a>00271    <span class="keywordflow">if</span> (!<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>)
<a name="l00272"></a>00272      <span class="keywordflow">return</span> FALSE;
<a name="l00273"></a>00273    <span class="keywordflow">for</span>( u8_tmp = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>; u8_tmp!=1 ; u8_tmp &gt;&gt;= 1 )
<a name="l00274"></a>00274    {
<a name="l00275"></a>00275      u32_tmp  &gt;&gt;= 1;   <span class="comment">// This computation round down</span>
<a name="l00276"></a>00276    }
<a name="l00277"></a>00277    <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a> = u32_tmp+2; <span class="comment">// The total of cluster include the two reserved clusters</span>
<a name="l00278"></a>00278 
<a name="l00279"></a>00279    <span class="comment">// Determine the FAT type</span>
<a name="l00280"></a>00280    <span class="keywordflow">if</span> (u32_tmp &lt; <a class="code" href="a00020.html#2f2a41f51db7209b1e068193cd10a9d8">FS_FAT12_MAX_CLUSTERS</a>)
<a name="l00281"></a>00281    {
<a name="l00282"></a>00282       <span class="comment">// Is FAT 12</span>
<a name="l00283"></a>00283 <span class="preprocessor">#if (FS_FAT_12 == DISABLED)</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span>      <span class="keywordflow">return</span> FALSE;
<a name="l00285"></a>00285 <span class="preprocessor">#endif</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>      <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920" title="FAT type (default = no mounted = FS_TYPE_FAT_UNM).">u8_type_fat</a> = <a class="code" href="a00020.html#cbc6a789e2144cbc0893187e2d665d8c">FS_TYPE_FAT_12</a>;
<a name="l00287"></a>00287    } <span class="keywordflow">else</span> {
<a name="l00288"></a>00288    <span class="keywordflow">if</span> (u32_tmp &lt; <a class="code" href="a00020.html#c1bec4fdf32e8ff9a9afc44b80607336">FS_FAT16_MAX_CLUSTERS</a>)
<a name="l00289"></a>00289    {
<a name="l00290"></a>00290       <span class="comment">// Is FAT 16</span>
<a name="l00291"></a>00291 <span class="preprocessor">#if (FS_FAT_16 == DISABLED)</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span>      <span class="keywordflow">return</span> FS_NO_SUPPORT_PART;
<a name="l00293"></a>00293 <span class="preprocessor">#endif</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span>      <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920" title="FAT type (default = no mounted = FS_TYPE_FAT_UNM).">u8_type_fat</a> = <a class="code" href="a00020.html#3433de4e69ce8d55317158ee2624e8af">FS_TYPE_FAT_16</a>;
<a name="l00295"></a>00295    } <span class="keywordflow">else</span> {
<a name="l00296"></a>00296       <span class="comment">// Is FAT 32</span>
<a name="l00297"></a>00297 <span class="preprocessor">#if (FS_FAT_32 == DISABLED)</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>      <span class="keywordflow">return</span> FALSE;
<a name="l00299"></a>00299 <span class="preprocessor">#endif</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>      <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920" title="FAT type (default = no mounted = FS_TYPE_FAT_UNM).">u8_type_fat</a> = <a class="code" href="a00020.html#bed7b1e094b19dac8efa753f59f84fc6">FS_TYPE_FAT_32</a>;
<a name="l00301"></a>00301       <span class="comment">// In FAT32, the root dir is like another directory, this one have a cluster list</span>
<a name="l00302"></a>00302       <span class="comment">// Get the first cluster number of root</span>
<a name="l00303"></a>00303       LSB0( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b" title="For FAT32, the root directory is a cluster list.">u32_cluster</a> ) = <a class="code" href="a00020.html#0a4a06552fb3a44093ef87a09fc2840f">LOW0_32_BPB_RootClus</a>;
<a name="l00304"></a>00304       LSB1( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b" title="For FAT32, the root directory is a cluster list.">u32_cluster</a> ) = <a class="code" href="a00020.html#dd80ee1ba4292b33a35bb9794e46b91d">LOW1_32_BPB_RootClus</a>;
<a name="l00305"></a>00305       LSB2( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b" title="For FAT32, the root directory is a cluster list.">u32_cluster</a> ) = <a class="code" href="a00020.html#47260296ce546b21bd10d3ddc963a2c7">LOW2_32_BPB_RootClus</a>;
<a name="l00306"></a>00306       LSB3( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b" title="For FAT32, the root directory is a cluster list.">u32_cluster</a> ) = <a class="code" href="a00020.html#68f0eada6fa2bbfffcdc98fcd463d225">LOW3_32_BPB_RootClus</a>;
<a name="l00307"></a>00307    }
<a name="l00308"></a>00308    }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310    <span class="keywordflow">return</span> TRUE;
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="preprocessor">#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES &amp; FSFEATURE_WRITE_COMPLET) )</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>
<a name="l00318"></a>00318 _MEM_TYPE_SLOW_   U32 <a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>;
<a name="l00319"></a><a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">00319</a> 
<a name="l00340"></a>00340 Bool  <a class="code" href="a00020.html#6099b0e8fafcc01b8c1769c94c827325" title="This function formats the drive.">fat_format</a>( U8 u8_fat_type )
<a name="l00341"></a><a class="code" href="a00021.html#6099b0e8fafcc01b8c1769c94c827325">00341</a> {
<a name="l00342"></a>00342    Bool b_MBR;
<a name="l00343"></a>00343 <span class="preprocessor">#if (FS_MULTI_PARTITION == ENABLED)</span>
<a name="l00344"></a>00344 <span class="preprocessor"></span><span class="preprocessor">#error NOT SUPPORTED</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span>   <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af482bc02a186c363c37c93e169fbbd4" title="Number of partition - 1 (0 or 1).">u8_partition</a> = 0;
<a name="l00346"></a>00346 <span class="preprocessor">#endif</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span>
<a name="l00348"></a>00348 
<a name="l00349"></a>00349    <span class="comment">// Get drive capacity (= last LBA)</span>
<a name="l00350"></a>00350    <a class="code" href="a00017.html#0bafaa7d437e08a1727e2124db423f18" title="Returns the address of the last valid sector (512 bytes) in the memory.">mem_read_capacity</a>( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#43065262a1a7560b143e0b48cbf5ccbd" title="Number of logical driver.">u8_lun</a> , &amp;<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a> );
<a name="l00351"></a>00351 
<a name="l00352"></a>00352    <span class="keywordflow">if</span>( u8_fat_type &amp; <a class="code" href="a00024.html#31e4d71ce14847632a35192fae12705e" title="MBR is mandatory for USB device on MacOS, and no MBR is mandatory for CD-ROM USB...">FS_FORMAT_NOMBR_FLAG</a> )
<a name="l00353"></a>00353    {
<a name="l00354"></a>00354       b_MBR = FALSE;
<a name="l00355"></a>00355       u8_fat_type &amp;= ~FS_FORMAT_NOMBR_FLAG;
<a name="l00356"></a>00356       <span class="comment">// partition size = disk size = last LBA + 1</span>
<a name="l00357"></a>00357       <a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>++;
<a name="l00358"></a>00358    }<span class="keywordflow">else</span>{
<a name="l00359"></a>00359       b_MBR = TRUE;
<a name="l00360"></a>00360       <span class="comment">// partition size = size disk -1 = last LBA</span>
<a name="l00361"></a>00361    }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363    <span class="comment">// Compute the FAT type for the device</span>
<a name="l00364"></a>00364    <span class="keywordflow">if</span>( !<a class="code" href="a00021.html#477e90a97f3fcb8361020feb2557098d" title="This function computes the FAT type to use.">fat_select_filesystem</a>( u8_fat_type , b_MBR ))
<a name="l00365"></a>00365       <span class="keywordflow">return</span> FALSE;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367    <span class="comment">// Write the MBR sector (first sector)</span>
<a name="l00368"></a>00368    <span class="keywordflow">if</span>( b_MBR )
<a name="l00369"></a>00369       <span class="keywordflow">if</span>( !<a class="code" href="a00021.html#9075855486dc53d38dd64e068b512027" title="This function writes the MBR.">fat_write_MBR</a>())
<a name="l00370"></a>00370          <span class="keywordflow">return</span> FALSE;
<a name="l00371"></a>00371 
<a name="l00372"></a>00372    <span class="comment">// Write the PBR sector</span>
<a name="l00373"></a>00373    <span class="keywordflow">if</span>( !<a class="code" href="a00021.html#89d56497bd58d7d6553b7e319f3ee863" title="This function writes the PBR.">fat_write_PBR</a>( b_MBR ))
<a name="l00374"></a>00374       <span class="keywordflow">return</span> FALSE;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376    <span class="comment">// Clear reserved zone, FAT zone, and Root dir zone</span>
<a name="l00377"></a>00377    <span class="comment">// Remark: the reserved zone of FAT32 isn't initialized, because BPB_FSInfo is equal to 0</span>
<a name="l00378"></a>00378    <span class="keywordflow">if</span>( !<a class="code" href="a00021.html#ad6177926c645c867ea1d23c727d9097" title="This function cleans the reserved zone, FAT zone, and root dir zone.">fat_clean_zone</a>( b_MBR ))
<a name="l00379"></a>00379       <span class="keywordflow">return</span> FALSE;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381    <span class="comment">// Initialization of the FAT 1 and 2</span>
<a name="l00382"></a>00382    <span class="keywordflow">if</span>( !<a class="code" href="a00021.html#6ab74fa9e68a4379a3ea33465d835277" title="This function initializes the fat one and two.">fat_initialize_fat</a>())
<a name="l00383"></a>00383       <span class="keywordflow">return</span> FALSE;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385    <span class="keywordflow">return</span> <a class="code" href="a00019.html#578ab4800128cde17c0820a5027c1c06" title="This function flushs the sector cache on the memory if necessary.">fat_cache_flush</a>();
<a name="l00386"></a>00386 }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 
<a name="l00391"></a>00391 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="a00013.html">st_fs_format_table</a> {
<a name="l00392"></a><a class="code" href="a00013.html">00392</a>    U32   <a class="code" href="a00013.html#489190e47d9a68fd2ca8c815d6ee5204">u32_disk_size</a>;
<a name="l00393"></a><a class="code" href="a00013.html#489190e47d9a68fd2ca8c815d6ee5204">00393</a>    U8    <a class="code" href="a00013.html#306fe57a245253891d9df17abbf51522">u8_SecPerClusVal</a>;
<a name="l00394"></a><a class="code" href="a00013.html#306fe57a245253891d9df17abbf51522">00394</a> } <a class="code" href="a00013.html">Fs_format_table</a>;
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 
<a name="l00398"></a>00398 _CONST_TYPE_ <a class="code" href="a00013.html">Fs_format_table</a> <a class="code" href="a00021.html#12c9e9d2a4cbd29f35072cccecc0f0d5" title="Table format for FAT12.">TableFAT12</a>[] = {
<a name="l00399"></a><a class="code" href="a00021.html#12c9e9d2a4cbd29f35072cccecc0f0d5">00399</a>    {  4096, 1},      <span class="comment">// disks up to 2 MB, 512 bytes cluster</span>
<a name="l00400"></a>00400    {  8192, 2},      <span class="comment">// disks up to 4 MB, 1k cluster</span>
<a name="l00401"></a>00401    { 16384, 4},      <span class="comment">// disks up to 8 MB, 2k cluster</span>
<a name="l00402"></a>00402    { 32680, 8},      <span class="comment">// disks up to 16 MB, 4k cluster</span>
<a name="l00403"></a>00403 };
<a name="l00404"></a>00404 <span class="comment">/*</span>
<a name="l00405"></a>00405 <span class="comment">NOTE: that this table includes</span>
<a name="l00406"></a>00406 <span class="comment">entries for disk sizes larger than 16 MB even though typically</span>
<a name="l00407"></a>00407 <span class="comment">only the entries for disks &lt; 16 MB in size are used.</span>
<a name="l00408"></a>00408 <span class="comment">The way this table is accessed is to look for the first entry</span>
<a name="l00409"></a>00409 <span class="comment">in the table for which the disk size is less than or equal</span>
<a name="l00410"></a>00410 <span class="comment">to the DiskSize field in that table entry. For this table to</span>
<a name="l00411"></a>00411 <span class="comment">work properly BPB_RsvdSecCnt must be 1, BPB_NumFATs</span>
<a name="l00412"></a>00412 <span class="comment">must be 2, and BPB_RootEntCnt must be 512.</span>
<a name="l00413"></a>00413 <span class="comment">*/</span>
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 
<a name="l00417"></a>00417 _CONST_TYPE_ <a class="code" href="a00013.html">Fs_format_table</a> <a class="code" href="a00021.html#e060256d5bbd91d6412e3601893935b4" title="Table format for FAT16.">TableFAT16</a>[] = {
<a name="l00418"></a><a class="code" href="a00021.html#e060256d5bbd91d6412e3601893935b4">00418</a>    { 8400, 0},       <span class="comment">// disks up to 4.1 MB, the 0 value for SecPerClusVal trips an error</span>
<a name="l00419"></a>00419    { 32680, 2},      <span class="comment">// disks up to 16 MB, 1k cluster</span>
<a name="l00420"></a>00420    { 262144, 4},     <span class="comment">// disks up to 128 MB, 2k cluster</span>
<a name="l00421"></a>00421    { 524288, 8},     <span class="comment">// disks up to 256 MB, 4k cluster</span>
<a name="l00422"></a>00422    { 1048576, 16},   <span class="comment">// disks up to 512 MB, 8k cluster</span>
<a name="l00423"></a>00423    <span class="comment">// The entries after this point are not used unless FAT16 is forced</span>
<a name="l00424"></a>00424    { 2097152, 32},   <span class="comment">// disks up to 1 GB, 16k cluster</span>
<a name="l00425"></a>00425    { 4194304, 64},   <span class="comment">// disks up to 2 GB, 32k cluster</span>
<a name="l00426"></a>00426    { 0xFFFFFFFF, 0}  <span class="comment">// any disk greater than 2GB, 0 value for SecPerClusVal trips an error</span>
<a name="l00427"></a>00427 };
<a name="l00428"></a>00428 <span class="comment">/*</span>
<a name="l00429"></a>00429 <span class="comment">NOTE: that this table includes</span>
<a name="l00430"></a>00430 <span class="comment">entries for disk sizes larger than 512 MB even though typically</span>
<a name="l00431"></a>00431 <span class="comment">only the entries for disks &lt; 512 MB in size are used.</span>
<a name="l00432"></a>00432 <span class="comment">The way this table is accessed is to look for the first entry</span>
<a name="l00433"></a>00433 <span class="comment">in the table for which the disk size is less than or equal</span>
<a name="l00434"></a>00434 <span class="comment">to the DiskSize field in that table entry. For this table to</span>
<a name="l00435"></a>00435 <span class="comment">work properly BPB_RsvdSecCnt must be 1, BPB_NumFATs</span>
<a name="l00436"></a>00436 <span class="comment">must be 2, and BPB_RootEntCnt must be 512. Any of these values</span>
<a name="l00437"></a>00437 <span class="comment">being different may require the first table entries DiskSize value</span>
<a name="l00438"></a>00438 <span class="comment">to be changed otherwise the cluster count may be to low for FAT16.</span>
<a name="l00439"></a>00439 <span class="comment">*/</span>
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 
<a name="l00443"></a>00443 _CONST_TYPE_ <a class="code" href="a00013.html">Fs_format_table</a> <a class="code" href="a00021.html#c25415e8010641385456353f4c1c5eec" title="Table format for FAT32.">TableFAT32</a>[] = {
<a name="l00444"></a><a class="code" href="a00021.html#c25415e8010641385456353f4c1c5eec">00444</a>    { 66600, 0},      <span class="comment">// disks up to 32.5 MB, the 0 value for SecPerClusVal trips an error</span>
<a name="l00445"></a>00445    { 532480, 1},     <span class="comment">// disks up to 260 MB, .5k cluster</span>
<a name="l00446"></a>00446    { 16777216, 8},   <span class="comment">// disks up to 8 GB, 4k cluster</span>
<a name="l00447"></a>00447    { 33554432, 16},  <span class="comment">// disks up to 16 GB, 8k cluster</span>
<a name="l00448"></a>00448    { 67108864, 32},  <span class="comment">// disks up to 32 GB, 16k cluster</span>
<a name="l00449"></a>00449    { 0xFFFFFFFF, 64} <span class="comment">// disks greater than 32GB, 32k cluster</span>
<a name="l00450"></a>00450 };
<a name="l00451"></a>00451 <span class="comment">/*</span>
<a name="l00452"></a>00452 <span class="comment">NOTE: that this table includes</span>
<a name="l00453"></a>00453 <span class="comment">entries for disk sizes smaller than 512 MB even though typically</span>
<a name="l00454"></a>00454 <span class="comment">only the entries for disks &gt;= 512 MB in size are used.</span>
<a name="l00455"></a>00455 <span class="comment">The way this table is accessed is to look for the first entry</span>
<a name="l00456"></a>00456 <span class="comment">in the table for which the disk size is less than or equal</span>
<a name="l00457"></a>00457 <span class="comment">to the DiskSize field in that table entry. For this table to</span>
<a name="l00458"></a>00458 <span class="comment">work properly BPB_RsvdSecCnt must be 32, and BPB_NumFATs</span>
<a name="l00459"></a>00459 <span class="comment">must be 2. Any of these values being different may require the first</span>
<a name="l00460"></a>00460 <span class="comment">table entries DiskSize value to be changed otherwise the cluster count</span>
<a name="l00461"></a>00461 <span class="comment">may be to low for FAT32.</span>
<a name="l00462"></a>00462 <span class="comment">*/</span>
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 
<a name="l00467"></a>00467 
<a name="l00483"></a>00483 Bool  <a class="code" href="a00021.html#477e90a97f3fcb8361020feb2557098d" title="This function computes the FAT type to use.">fat_select_filesystem</a>( U8 u8_fat_type , Bool b_MBR )
<a name="l00484"></a><a class="code" href="a00021.html#477e90a97f3fcb8361020feb2557098d">00484</a> {
<a name="l00485"></a>00485    U8 u8_i;
<a name="l00486"></a>00486    U8 u8_tmp = 0;
<a name="l00487"></a>00487    U16  u16_tmp, u16_tmp2;
<a name="l00488"></a>00488    <a class="code" href="a00013.html">Fs_format_table</a> _CONST_TYPE_ *ptr_table;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490    <span class="keywordflow">if</span>( (<a class="code" href="a00024.html#df4231c592cf152d2fa607e43ec3071e" title="Force FAT12 or FAT16 format.">FS_FORMAT_FAT</a>   != u8_fat_type )
<a name="l00491"></a>00491    &amp;&amp;  (<a class="code" href="a00024.html#052a9dbafcad051e18df689130f9b256" title="Force FAT32 format.">FS_FORMAT_FAT32</a> != u8_fat_type ) )
<a name="l00492"></a>00492    {
<a name="l00493"></a>00493       <span class="comment">// Default format then select the better FAT type</span>
<a name="l00494"></a>00494       <span class="keywordflow">if</span>( (((U32)512*1024*1024)/<a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a>) &gt;= <a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>  )
<a name="l00495"></a>00495       {
<a name="l00496"></a>00496          u8_fat_type = <a class="code" href="a00024.html#df4231c592cf152d2fa607e43ec3071e" title="Force FAT12 or FAT16 format.">FS_FORMAT_FAT</a>;
<a name="l00497"></a>00497       } <span class="keywordflow">else</span> {
<a name="l00498"></a>00498          u8_fat_type = <a class="code" href="a00024.html#052a9dbafcad051e18df689130f9b256" title="Force FAT32 format.">FS_FORMAT_FAT32</a>;
<a name="l00499"></a>00499       }
<a name="l00500"></a>00500    }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502    <span class="comment">//** Verify the FAT type choosed</span>
<a name="l00503"></a>00503    <span class="keywordflow">if</span>(<a class="code" href="a00024.html#df4231c592cf152d2fa607e43ec3071e" title="Force FAT12 or FAT16 format.">FS_FORMAT_FAT</a> == u8_fat_type )
<a name="l00504"></a>00504    {
<a name="l00505"></a>00505       <span class="keywordflow">if</span>( (((U32)2*1024*1024)/<a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a>) &gt;= <a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>  )
<a name="l00506"></a>00506       {
<a name="l00507"></a>00507          <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#2efe3f002eae619a40b7a31834245014" title="The disk size is too small for format routine.">FS_ERR_DEVICE_TOO_SMALL</a>;    <span class="comment">// The disk size is not supported</span>
<a name="l00508"></a>00508          <span class="keywordflow">return</span> FALSE;
<a name="l00509"></a>00509       }
<a name="l00510"></a>00510       <span class="keywordflow">if</span>( (((U32)15*1024*1024)/<a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a>) &gt;= <a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>  )
<a name="l00511"></a>00511       {
<a name="l00512"></a>00512          <span class="comment">// FAT 12 format</span>
<a name="l00513"></a>00513          <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920" title="FAT type (default = no mounted = FS_TYPE_FAT_UNM).">u8_type_fat</a> = <a class="code" href="a00020.html#cbc6a789e2144cbc0893187e2d665d8c">FS_TYPE_FAT_12</a>;
<a name="l00514"></a>00514          u8_i = <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#12c9e9d2a4cbd29f35072cccecc0f0d5" title="Table format for FAT12.">TableFAT12</a>);
<a name="l00515"></a>00515          ptr_table = <a class="code" href="a00021.html#12c9e9d2a4cbd29f35072cccecc0f0d5" title="Table format for FAT12.">TableFAT12</a>;
<a name="l00516"></a>00516       }<span class="keywordflow">else</span>{
<a name="l00517"></a>00517          <span class="comment">// FAT 16 format</span>
<a name="l00518"></a>00518          <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920" title="FAT type (default = no mounted = FS_TYPE_FAT_UNM).">u8_type_fat</a> = <a class="code" href="a00020.html#3433de4e69ce8d55317158ee2624e8af">FS_TYPE_FAT_16</a>;
<a name="l00519"></a>00519          u8_i = <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#e060256d5bbd91d6412e3601893935b4" title="Table format for FAT16.">TableFAT16</a>);
<a name="l00520"></a>00520          ptr_table = <a class="code" href="a00021.html#e060256d5bbd91d6412e3601893935b4" title="Table format for FAT16.">TableFAT16</a>;
<a name="l00521"></a>00521       }
<a name="l00522"></a>00522    }
<a name="l00523"></a>00523    <span class="keywordflow">else</span>
<a name="l00524"></a>00524    {  <span class="comment">// FAT 32 format</span>
<a name="l00525"></a>00525       <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920" title="FAT type (default = no mounted = FS_TYPE_FAT_UNM).">u8_type_fat</a> = <a class="code" href="a00020.html#bed7b1e094b19dac8efa753f59f84fc6">FS_TYPE_FAT_32</a>;
<a name="l00526"></a>00526       u8_i = <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#c25415e8010641385456353f4c1c5eec" title="Table format for FAT32.">TableFAT32</a>);
<a name="l00527"></a>00527       ptr_table = <a class="code" href="a00021.html#c25415e8010641385456353f4c1c5eec" title="Table format for FAT32.">TableFAT32</a>;
<a name="l00528"></a>00528    }
<a name="l00529"></a>00529    <span class="keywordflow">for</span>(  ; u8_i!=0 ; u8_i-- )
<a name="l00530"></a>00530    {
<a name="l00531"></a>00531       <span class="keywordflow">if</span>( fs_s_u32_size_partition &lt;= ptr_table-&gt;u32_disk_size )
<a name="l00532"></a>00532       {
<a name="l00533"></a>00533          <span class="comment">// Get cluster size (unit sector)</span>
<a name="l00534"></a>00534          <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a> = ptr_table-&gt;u8_SecPerClusVal;
<a name="l00535"></a>00535          <span class="keywordflow">break</span>;
<a name="l00536"></a>00536       }
<a name="l00537"></a>00537       ptr_table++;
<a name="l00538"></a>00538    }
<a name="l00539"></a>00539    <span class="keywordflow">if</span>(0 == <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>)
<a name="l00540"></a>00540    {
<a name="l00541"></a>00541       <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#71c0c3d03cdea7bfff5f3a97a8020a33" title="The disk size is not supported by selected FAT format.">FS_ERR_BAD_SIZE_FAT</a>;    <span class="comment">// The disk size is not supported by selected FAT type</span>
<a name="l00542"></a>00542       <span class="keywordflow">return</span> FALSE;
<a name="l00543"></a>00543    }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545    <span class="comment">//** Compute fat size</span>
<a name="l00546"></a>00546    <span class="comment">// Compute PBR address</span>
<a name="l00547"></a>00547    <span class="keywordflow">if</span>( b_MBR )
<a name="l00548"></a>00548       <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> = 1;  <span class="comment">// MBR exist</span>
<a name="l00549"></a>00549    <span class="keywordflow">else</span>
<a name="l00550"></a>00550       <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> = 0;  <span class="comment">// no MBR</span>
<a name="l00551"></a>00551 
<a name="l00552"></a>00552    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l00553"></a>00553    {  <span class="comment">// FAT 12</span>
<a name="l00554"></a>00554       <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> += 1;  <span class="comment">// FAT address = PBR address + 1</span>
<a name="l00555"></a>00555       <span class="comment">// Try all possibility of FAT12 size</span>
<a name="l00556"></a>00556       <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>=1;
<a name="l00557"></a>00557       <span class="keywordflow">while</span>(1)
<a name="l00558"></a>00558       {
<a name="l00559"></a>00559          <span class="keywordflow">if</span>( 12 &lt; <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>)        <span class="comment">// Max FAT size in FAT12 mode (unit sector) (=0xFFE*1.5/FS_512B)</span>
<a name="l00560"></a>00560          {
<a name="l00561"></a>00561             <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#71c0c3d03cdea7bfff5f3a97a8020a33" title="The disk size is not supported by selected FAT format.">FS_ERR_BAD_SIZE_FAT</a>;  <span class="comment">// The disk size is not supported by file system selected</span>
<a name="l00562"></a>00562             <span class="keywordflow">return</span> FALSE;
<a name="l00563"></a>00563          }
<a name="l00564"></a>00564          <span class="comment">// Check if the number of cluster corresponding at data zone size</span>
<a name="l00565"></a>00565          <span class="comment">// Note: -1 to not compute PBR sector</span>
<a name="l00566"></a>00566          u16_tmp  = ((<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a> -1 - (<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a> *2)) / <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>)+2;
<a name="l00567"></a>00567          u16_tmp2 = (<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a> *<a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a> *2) / 3;
<a name="l00568"></a>00568          <span class="keywordflow">if</span>( u16_tmp &lt;= u16_tmp2 )
<a name="l00569"></a>00569             <span class="keywordflow">break</span>;   <span class="comment">// FAT size OK</span>
<a name="l00570"></a>00570 
<a name="l00571"></a>00571          <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>++;
<a name="l00572"></a>00572       }
<a name="l00573"></a>00573    }
<a name="l00574"></a>00574    <span class="keywordflow">else</span>
<a name="l00575"></a>00575    {
<a name="l00576"></a>00576       <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00577"></a>00577       {  <span class="comment">// FAT 32</span>
<a name="l00578"></a>00578          <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> += 32;  <span class="comment">// FAT address = PBR address + BPB_ResvSecCnt</span>
<a name="l00579"></a>00579          <span class="comment">// RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec  1)) / BPB_BytsPerSec;</span>
<a name="l00580"></a>00580          <span class="comment">//                = (FS_512B-1) / FS_512B = 0</span>
<a name="l00581"></a>00581          <span class="comment">// TmpVal1        = DskSize  (BPB_ResvdSecCnt + RootDirSectors);</span>
<a name="l00582"></a>00582          <span class="comment">//                = fs_s_u32_size_partition - (32 + 0)</span>
<a name="l00583"></a>00583          <span class="comment">//                = fs_s_u32_size_partition - u8_tmp</span>
<a name="l00584"></a>00584          u8_tmp = 32;
<a name="l00585"></a>00585          <span class="comment">// TmpVal2        = ((256 * BPB_SecPerClus) + BPB_NumFATs )/2;</span>
<a name="l00586"></a>00586          <span class="comment">//                = ((((U16)fs_g_nav.u8_BPB_SecPerClus)&lt;&lt;8) + 2) &gt;&gt; 1;</span>
<a name="l00587"></a>00587          <span class="comment">//                = (((U16)fs_g_nav.u8_BPB_SecPerClus)&lt;&lt;7) + 1;</span>
<a name="l00588"></a>00588          <span class="comment">//                = u16_tmp</span>
<a name="l00589"></a>00589          u16_tmp = (((U16)<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>)&lt;&lt;7) + 1;
<a name="l00590"></a>00590          <span class="comment">// BPB_FATSz16    = 0;</span>
<a name="l00591"></a>00591          <span class="comment">// BPB_FATSz32    = FATSz;</span>
<a name="l00592"></a>00592       }
<a name="l00593"></a>00593       <span class="keywordflow">if</span>( <a class="code" href="a00020.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l00594"></a>00594       {  <span class="comment">// FAT 16</span>
<a name="l00595"></a>00595          <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> += 1;  <span class="comment">// FAT address = PBR address + BPB_ResvSecCnt</span>
<a name="l00596"></a>00596          <span class="comment">// RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec  1))  / BPB_BytsPerSec</span>
<a name="l00597"></a>00597          <span class="comment">//                = ((512            * 32) + (FS_512B-1)) / FS_512B</span>
<a name="l00598"></a>00598          <span class="comment">//                = 32</span>
<a name="l00599"></a>00599          <span class="comment">// TmpVal1        = DskSize  (BPB_ResvdSecCnt + RootDirSectors);</span>
<a name="l00600"></a>00600          <span class="comment">//                = fs_s_u32_size_partition - (1 + 32)</span>
<a name="l00601"></a>00601          <span class="comment">//                = fs_s_u32_size_partition - u8_tmp</span>
<a name="l00602"></a>00602          u8_tmp = 33;
<a name="l00603"></a>00603          <span class="comment">// TmpVal2        = ((256 * BPB_SecPerClus) + BPB_NumFATs )/2;</span>
<a name="l00604"></a>00604          <span class="comment">//                = (((U16)fs_g_nav.u8_BPB_SecPerClus)&lt;&lt;8) + 2;</span>
<a name="l00605"></a>00605          <span class="comment">//                = u16_tmp</span>
<a name="l00606"></a>00606          MSB(u16_tmp) = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>;
<a name="l00607"></a>00607          LSB(u16_tmp) = 2;
<a name="l00608"></a>00608       }
<a name="l00609"></a>00609       <span class="comment">// FATSz          = (TMPVal1 + TmpVal2  1) / TmpVal2;</span>
<a name="l00610"></a>00610       <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a> = (<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a> -u8_tmp +u16_tmp -1) / u16_tmp;
<a name="l00611"></a>00611    }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613    <span class="keywordflow">return</span> TRUE;
<a name="l00614"></a>00614 }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 
<a name="l00622"></a>00622 Bool  <a class="code" href="a00021.html#9075855486dc53d38dd64e068b512027" title="This function writes the MBR.">fat_write_MBR</a>( <span class="keywordtype">void</span> )
<a name="l00623"></a><a class="code" href="a00021.html#9075855486dc53d38dd64e068b512027">00623</a> {
<a name="l00624"></a>00624    U8 u8_i = 0;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626    <span class="comment">// Init and reset the internal cache at the beginning of memory</span>
<a name="l00627"></a>00627    <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = 0;
<a name="l00628"></a>00628    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( FALSE ))
<a name="l00629"></a>00629       <span class="keywordflow">return</span> FALSE;
<a name="l00630"></a>00630    <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l00631"></a>00631    <a class="code" href="a00019.html#5948c1de515852418670d3fb8ae1e832" title="This function clears the sector cache.">fat_cache_clear</a>();
<a name="l00632"></a>00632 
<a name="l00633"></a>00633    <span class="comment">// MBR signature</span>
<a name="l00634"></a>00634    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[510] = <a class="code" href="a00020.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a>;
<a name="l00635"></a>00635    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[511] = <a class="code" href="a00020.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a>;
<a name="l00636"></a>00636 
<a name="l00637"></a>00637    <span class="comment">// Write the partition entry in the MBR</span>
<a name="l00638"></a>00638    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0) +0] = <a class="code" href="a00020.html#e9933a03e28f302f391f377b8efc001d">FS_PART_NO_BOOTABLE</a>;   <span class="comment">// Active partition</span>
<a name="l00639"></a>00639    <span class="comment">// Remark: cylinder and header start to 0, and sector value start to 1</span>
<a name="l00640"></a>00640    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0) +1] = 0;                   // The head (0) where the partition starts</span>
<a name="l00641"></a>00641    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0) +2] = 2;                     <span class="comment">// The sector (2=next to MBR) and the cylinder (0) where the partition starts</span>
<a name="l00642"></a>00642    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0) +3] = 0;</span>
<a name="l00643"></a>00643 
<a name="l00644"></a>00644    <span class="comment">// Write patition type</span>
<a name="l00645"></a>00645    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00646"></a>00646    {  <span class="comment">// FAT 32</span>
<a name="l00647"></a>00647       u8_i = <a class="code" href="a00020.html#93881dd293ba41286e413bef3212786a">FS_PART_TYPE_FAT32</a>;
<a name="l00648"></a>00648    }
<a name="l00649"></a>00649    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l00650"></a>00650    {  <span class="comment">// FAT 16</span>
<a name="l00651"></a>00651       <span class="keywordflow">if</span>( <a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a> &lt; (32L*1024*(1024/<a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a>)) )
<a name="l00652"></a>00652       {  <span class="comment">// Disk &lt; 32MB</span>
<a name="l00653"></a>00653          u8_i = <a class="code" href="a00020.html#b9f13193999f7bb7ea0e4be6cf5ee57b">FS_PART_TYPE_FAT16_INF32M</a>;
<a name="l00654"></a>00654       }<span class="keywordflow">else</span>{
<a name="l00655"></a>00655          u8_i = <a class="code" href="a00020.html#29856400974fc942f9cf900a44ea7389">FS_PART_TYPE_FAT16_SUP32M</a>;
<a name="l00656"></a>00656       }
<a name="l00657"></a>00657    }
<a name="l00658"></a>00658    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l00659"></a>00659    {  <span class="comment">// FAT 12</span>
<a name="l00660"></a>00660       u8_i = <a class="code" href="a00020.html#d8702ceb3912c09278602d3ea33224ff">FS_PART_TYPE_FAT12</a>;
<a name="l00661"></a>00661    }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0) +4] = u8_i;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665    <span class="comment">// The head where the partitions ends</span>
<a name="l00666"></a>00666    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0) +5] = (LSB1(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&lt;&lt;2) + (LSB0(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&gt;&gt;6);
<a name="l00667"></a>00667    <span class="comment">// The sector and the cylinder where the partition ends</span>
<a name="l00668"></a>00668    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0) +6] = (LSB1(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&amp;0xC0) + (LSB0(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&amp;0x3F);
<a name="l00669"></a>00669    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0) +7] = LSB2(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671    <span class="comment">// Write partition position (in sectors) at offset 8</span>
<a name="l00672"></a>00672    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0)+ 8] = 0x01;
<a name="l00673"></a>00673    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0)+ 9] = 0x00;</span>
<a name="l00674"></a>00674    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0)+10] = 0x00;</span>
<a name="l00675"></a>00675    <span class="comment">//fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(0)+11] = 0x00;</span>
<a name="l00676"></a>00676    <span class="comment">// Write the number of sector in partition (= size - one sector MBR = last LBA, return by read_capacity)</span>
<a name="l00677"></a>00677    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0)+12] = LSB0(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00678"></a>00678    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0)+13] = LSB1(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00679"></a>00679    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0)+14] = LSB2(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00680"></a>00680    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#70b90ba913c43a878e9b478de5d1b61c" title="Position (unit byte) in the MBR of a partition entry.">FS_MBR_OFFSET_PART_ENTRY</a>(0)+15] = LSB3(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682    <span class="keywordflow">return</span> TRUE;
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00686"></a>00686 _CONST_TYPE_ U8 <a class="code" href="a00021.html#6b6070b3785c1dcfd6b94c639a1039c3">const_header_pbr</a>[] = {
<a name="l00687"></a><a class="code" href="a00021.html#6b6070b3785c1dcfd6b94c639a1039c3">00687</a>    0xEB,0,0x90,                                       <span class="comment">// offset 00-02, Add jump boot flag</span>
<a name="l00688"></a>00688    <span class="charliteral">'M'</span>,<span class="charliteral">'S'</span>,<span class="charliteral">'W'</span>,<span class="charliteral">'I'</span>,<span class="charliteral">'N'</span>,<span class="charliteral">'4'</span>,<span class="charliteral">'.'</span>,<span class="charliteral">'1'</span>,                   <span class="comment">// offset 03-11, No add OEM name</span>
<a name="l00689"></a>00689    <a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a> &amp; 0xFF, <a class="code" href="a00020.html#e6e52ba6ed3159395fab025719b91bd0">FS_512B</a> &gt;&gt;8,                       <span class="comment">// offset 11-12, Add byte per sector</span>
<a name="l00690"></a>00690    0,                                                 <span class="comment">// offset 13-13, Add sector by cluster</span>
<a name="l00691"></a>00691    0,0,                                               <span class="comment">// offset 14-15, Add Number of reserved sector (see next step for optimization test)</span>
<a name="l00692"></a>00692    2,                                                 <span class="comment">// offset 16-16, Add Number of FAT</span>
<a name="l00693"></a>00693    0,0,                                               <span class="comment">// offset 17-18, Add Number of root entry (FAT32 = 0 entry, FAT16 = 512 entrys)</span>
<a name="l00694"></a>00694    0,0,
<a name="l00695"></a>00695    <a class="code" href="a00020.html#3222ba68ea2f6dc67aa88a0caeb7e6e4">FS_PART_NO_REMOVE_MEDIA</a>,                           <span class="comment">// offset 21-21, Media byte</span>
<a name="l00696"></a>00696    0,0,
<a name="l00697"></a>00697    0x3F,0,                                            <span class="comment">// offset 24-25, Sector per track (must be egal to MBR information, also maximum sector per head = 0x3F = 6bits)</span>
<a name="l00698"></a>00698    0,0,                                               <span class="comment">// offset 26-27, Number of header</span>
<a name="l00699"></a>00699    1                                                  <span class="comment">// offset 28-31, Number of hidden setors</span>
<a name="l00700"></a>00700    };
<a name="l00701"></a>00701 _CONST_TYPE_ U8 <a class="code" href="a00021.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>[] = {           <span class="comment">// offset 36 on FAT 16, offset 64 on FAT 32</span>
<a name="l00702"></a><a class="code" href="a00021.html#0a7f54c3ba9425b8a19d431732e98391">00702</a>    <a class="code" href="a00020.html#3eecd129a66f4de0d5cd023f2f925e1e">FS_PART_HARD_DISK</a>,                                 <span class="comment">// Driver number</span>
<a name="l00703"></a>00703    0,                                                 <span class="comment">// Reserved (used by Windows NT)</span>
<a name="l00704"></a>00704    <a class="code" href="a00020.html#8b3d7dc9ad174dc5273cc5cb052598f1">FS_BOOT_SIGN</a>,                                      <span class="comment">// Extended boot signature</span>
<a name="l00705"></a>00705    0,0,0,0,                                           <span class="comment">// volume ID</span>
<a name="l00706"></a>00706    <span class="charliteral">'N'</span>,<span class="charliteral">'O'</span>,<span class="charliteral">' '</span>,<span class="charliteral">'N'</span>,<span class="charliteral">'A'</span>,<span class="charliteral">'M'</span>,<span class="charliteral">'E'</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,       <span class="comment">// volume label (11 characters);</span>
<a name="l00707"></a>00707    <span class="charliteral">'F'</span>,<span class="charliteral">'A'</span>,<span class="charliteral">'T'</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,<span class="charliteral">' '</span>,                   <span class="comment">// FAT type in ASCII (8 characters);</span>
<a name="l00708"></a>00708    };
<a name="l00709"></a>00709 
<a name="l00710"></a>00710 
<a name="l00713"></a>00713 _CONST_TYPE_ U8 <a class="code" href="a00021.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>[] = {
<a name="l00714"></a><a class="code" href="a00021.html#0ab271becae152fb0b33ad5eb33ec22b">00714</a>    0x52,0x52,0x61,0x41                                
<a name="l00715"></a>00715 };
<a name="l00716"></a>00716 _CONST_TYPE_ U8 <a class="code" href="a00021.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>[] = {
<a name="l00717"></a><a class="code" href="a00021.html#71e0de07d391ec4f20a8a1bb4b446f90">00717</a>    0x72,0x72,0x41,0x61                                
<a name="l00718"></a>00718 };
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 
<a name="l00729"></a>00729 Bool  <a class="code" href="a00021.html#89d56497bd58d7d6553b7e319f3ee863" title="This function writes the PBR.">fat_write_PBR</a>( Bool b_MBR )
<a name="l00730"></a><a class="code" href="a00021.html#89d56497bd58d7d6553b7e319f3ee863">00730</a> {
<a name="l00731"></a>00731    U16 u16_tmp;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733    <span class="comment">//** Init the cache sector with PBR</span>
<a name="l00734"></a>00734    <span class="keywordflow">if</span>( b_MBR )
<a name="l00735"></a>00735       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = 1;
<a name="l00736"></a>00736    <span class="keywordflow">else</span>
<a name="l00737"></a>00737       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = 0;
<a name="l00738"></a>00738 
<a name="l00739"></a>00739    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( FALSE ))
<a name="l00740"></a>00740       <span class="keywordflow">return</span> FALSE;
<a name="l00741"></a>00741    <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l00742"></a>00742    <a class="code" href="a00019.html#5948c1de515852418670d3fb8ae1e832" title="This function clears the sector cache.">fat_cache_clear</a>();
<a name="l00743"></a>00743 
<a name="l00744"></a>00744    <span class="comment">//** WRITE CONSTANTE &amp; VARIABLE FOR FAT and FAT32</span>
<a name="l00745"></a>00745    memcpy_code2ram( <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>, <a class="code" href="a00021.html#6b6070b3785c1dcfd6b94c639a1039c3">const_header_pbr</a> , <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#6b6070b3785c1dcfd6b94c639a1039c3">const_header_pbr</a>) );
<a name="l00746"></a>00746    <span class="comment">// PBR signature</span>
<a name="l00747"></a>00747    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[510] = <a class="code" href="a00020.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a>;
<a name="l00748"></a>00748    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[511] = <a class="code" href="a00020.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a>;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750    <span class="comment">// offset 13-13, Add sector by cluster</span>
<a name="l00751"></a>00751    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[13] = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>;
<a name="l00752"></a>00752    <span class="comment">// offset 26-27, Number of header</span>
<a name="l00753"></a>00753    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[26] = (LSB1(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&lt;&lt;2) + (LSB0(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>)&gt;&gt;6);
<a name="l00754"></a>00754 
<a name="l00755"></a>00755    <span class="comment">//** WRITE CONSTANTE &amp; VARIABLE DEPENDING OF FAT16 and FAT32</span>
<a name="l00756"></a>00756    <span class="comment">// Since offset 36, there are a different structure space for FAT16 and FAT32</span>
<a name="l00757"></a>00757    <span class="comment">// offset 39-42 or 67-70, Volume ID not used</span>
<a name="l00758"></a>00758    <span class="comment">// offset 43-53 or 71-81, Volume Label</span>
<a name="l00759"></a>00759    <span class="comment">// offset 54-61 or 82-89, File system type</span>
<a name="l00760"></a>00760    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00761"></a>00761    {
<a name="l00762"></a>00762       memcpy_code2ram( &amp;<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[64], <a class="code" href="a00021.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>) );
<a name="l00763"></a>00763    }<span class="keywordflow">else</span>{
<a name="l00764"></a>00764       memcpy_code2ram( &amp;<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[36], <a class="code" href="a00021.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#0a7f54c3ba9425b8a19d431732e98391">const_tail_pbr</a>) );
<a name="l00765"></a>00765    }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767    u16_tmp = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>;    <span class="comment">// save value in fast data space to optimize code</span>
<a name="l00768"></a>00768    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00769"></a>00769    {
<a name="l00770"></a>00770       <span class="comment">// offset 14-15, Add Number of reserved sector, FAT32 = 32 sectors</span>
<a name="l00771"></a>00771       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[14] = 32;
<a name="l00772"></a>00772       <span class="comment">// offset 17-18, Add Number of root entry, FAT32 = 0 entry</span>
<a name="l00773"></a>00773       <span class="comment">// offset 36-39, Fat size 32bits</span>
<a name="l00774"></a>00774       <a class="code" href="a00020.html#c1ba95f06dfaaf3c71a5eb12dd56009c">LOW0_32_BPB_FATSz32</a> = LSB(u16_tmp);
<a name="l00775"></a>00775       <a class="code" href="a00020.html#dff814b0d106b4c3b3f730fbef8338ce">LOW1_32_BPB_FATSz32</a> = MSB(u16_tmp);
<a name="l00776"></a>00776       <span class="comment">// offset 40-41, Ext flags (all FAT are enabled = 0)</span>
<a name="l00777"></a>00777       <span class="comment">// offset 42-43, Fs version (version0:0 = 0)</span>
<a name="l00778"></a>00778       <span class="comment">// offset 44-47, Root Cluster (first free cluster = 2)</span>
<a name="l00779"></a>00779       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[44]= 2;
<a name="l00780"></a>00780       <span class="comment">// offset 48-49, Fs Info (usualy 1)</span>
<a name="l00781"></a>00781       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[48]= 1;
<a name="l00782"></a>00782       <span class="comment">// offset 50-51, Backup Boot Sector (usualy 6)</span>
<a name="l00783"></a>00783       <span class="comment">// fs_g_sector[50]= 0;</span>
<a name="l00784"></a>00784       <span class="comment">// offset 52-63, reserved space</span>
<a name="l00785"></a>00785       <span class="comment">// offset 54-61, File system type</span>
<a name="l00786"></a>00786       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[85]=<span class="charliteral">'3'</span>;
<a name="l00787"></a>00787       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[86]=<span class="charliteral">'2'</span>;
<a name="l00788"></a>00788       <span class="comment">// Update FSInfo position</span>
<a name="l00789"></a>00789       <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#d7fc62fd6868a846c0f242c6cf35fe60" title="Offset between the beginning of FAT and the FSInfo sector (only used by FAT32) (unit...">u16_offset_FSInfo</a> = (32-1);
<a name="l00790"></a>00790    }
<a name="l00791"></a>00791    <span class="keywordflow">else</span>
<a name="l00792"></a>00792    {
<a name="l00793"></a>00793       <span class="comment">// FAT 12 or 16</span>
<a name="l00794"></a>00794       <span class="comment">// offset 14-15, Add Number of reserved sector, FAT = 1 sector</span>
<a name="l00795"></a>00795       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[14] = 1;
<a name="l00796"></a>00796       <span class="comment">// offset 17-18, Add Number of root entry, FAT = 512 entrys</span>
<a name="l00797"></a>00797       <span class="comment">//fs_g_sector[17] = 512&amp;0xFF;</span>
<a name="l00798"></a>00798       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[18] = 512&gt;&gt;8;
<a name="l00799"></a>00799 
<a name="l00800"></a>00800       <span class="comment">// offset 22-23, Fat size 16bits</span>
<a name="l00801"></a>00801       <a class="code" href="a00020.html#fe57e984b2baf3970ac7feda02355ac9">LOW_16_BPB_FATSz16</a>  = LSB(u16_tmp);
<a name="l00802"></a>00802       <a class="code" href="a00020.html#c7277af1ce6ee4efe860da2d1f3b1b38">HIGH_16_BPB_FATSz16</a> = MSB(u16_tmp);
<a name="l00803"></a>00803       <span class="comment">// offset 54-61, File system type</span>
<a name="l00804"></a>00804       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[57]=<span class="charliteral">'1'</span>;
<a name="l00805"></a>00805       <span class="keywordflow">if</span>( <a class="code" href="a00020.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l00806"></a>00806       {
<a name="l00807"></a>00807          <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[58]=<span class="charliteral">'2'</span>;
<a name="l00808"></a>00808       }<span class="keywordflow">else</span>{
<a name="l00809"></a>00809          <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[58]=<span class="charliteral">'6'</span>;
<a name="l00810"></a>00810       }
<a name="l00811"></a>00811    }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813    <span class="comment">// Write the number of sector in partition (= size - one sector MBR = last LBA, return by read_capacity)</span>
<a name="l00814"></a>00814    <span class="keywordflow">if</span>( ( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00815"></a>00815    ||  ((0x10000-1) &lt;= <a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>) )
<a name="l00816"></a>00816    {
<a name="l00817"></a>00817       <span class="comment">// FAT32 or disk &gt; 32MB</span>
<a name="l00818"></a>00818       <span class="comment">// offset 32-35, Number of sector in partition (value 32 bits)</span>
<a name="l00819"></a>00819       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[32] = LSB0(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00820"></a>00820       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[33] = LSB1(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00821"></a>00821       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[34] = LSB2(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00822"></a>00822       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[35] = LSB3(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00823"></a>00823    }
<a name="l00824"></a>00824    <span class="keywordflow">else</span>
<a name="l00825"></a>00825    {
<a name="l00826"></a>00826       <span class="comment">// offset 19-20, Number of sector in partition (value 16 bits)</span>
<a name="l00827"></a>00827       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[19] = LSB0(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00828"></a>00828       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[20] = LSB1(<a class="code" href="a00021.html#045dd8cfc387ec4ecf5c278bd239a5cf">fs_s_u32_size_partition</a>);
<a name="l00829"></a>00829    }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00832"></a>00832    {
<a name="l00833"></a>00833       <span class="comment">// Init the FAT32 FSInfo Sector</span>
<a name="l00834"></a>00834       <span class="keywordflow">if</span>( !<a class="code" href="a00020.html#9cf154ffe36bc2c00b1d589e523b449c" title="This function writes the space free number in selected FAT32 partition.">fat_write_fat32_FSInfo</a>( 0xFFFFFFFF ))
<a name="l00835"></a>00835          <span class="keywordflow">return</span> FALSE;
<a name="l00836"></a>00836    }
<a name="l00837"></a>00837    <span class="keywordflow">return</span> TRUE;
<a name="l00838"></a>00838 }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 <span class="preprocessor">#ifdef  FS_FAT_32</span>
<a name="l00852"></a>00852 <span class="preprocessor">Bool  fat_write_fat32_FSInfo( U32 u32_nb_free_cluster )</span>
<a name="l00853"></a><a class="code" href="a00021.html#9cf154ffe36bc2c00b1d589e523b449c">00853</a> <span class="preprocessor"></span>{
<a name="l00854"></a>00854    <span class="comment">// Init sector</span>
<a name="l00855"></a>00855    <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> - <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#d7fc62fd6868a846c0f242c6cf35fe60" title="Offset between the beginning of FAT and the FSInfo sector (only used by FAT32) (unit...">u16_offset_FSInfo</a>;
<a name="l00856"></a>00856 
<a name="l00857"></a>00857    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( FALSE ))
<a name="l00858"></a>00858       <span class="keywordflow">return</span> FALSE;
<a name="l00859"></a>00859    <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l00860"></a>00860    <a class="code" href="a00019.html#5948c1de515852418670d3fb8ae1e832" title="This function clears the sector cache.">fat_cache_clear</a>();
<a name="l00861"></a>00861 
<a name="l00862"></a>00862    <span class="comment">// Fill sector</span>
<a name="l00863"></a>00863    <span class="comment">// offset 00-04, This lead signature</span>
<a name="l00864"></a>00864    memcpy_code2ram( &amp;<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[0], <a class="code" href="a00021.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>) );
<a name="l00865"></a>00865    <span class="comment">// offset 004-483, reserved (fill with 0)</span>
<a name="l00866"></a>00866    <span class="comment">// offset 484-487, signature</span>
<a name="l00867"></a>00867    memcpy_code2ram( &amp;<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[484], <a class="code" href="a00021.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>) );
<a name="l00868"></a>00868    <span class="comment">// offset 488-491, free cluster count (by default NO value)</span>
<a name="l00869"></a>00869    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[488] = LSB0(u32_nb_free_cluster);
<a name="l00870"></a>00870    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[489] = LSB1(u32_nb_free_cluster);
<a name="l00871"></a>00871    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[490] = LSB2(u32_nb_free_cluster);
<a name="l00872"></a>00872    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[491] = LSB3(u32_nb_free_cluster);
<a name="l00873"></a>00873    <span class="comment">// offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)</span>
<a name="l00874"></a>00874    memset( &amp;<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[492] , 0xFF , 4 );
<a name="l00875"></a>00875    <span class="comment">// offset 496-509, reserved (fill with 0)</span>
<a name="l00876"></a>00876    <span class="comment">// offset 510-511, Signature</span>
<a name="l00877"></a>00877    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[510] = <a class="code" href="a00020.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a>;
<a name="l00878"></a>00878    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[511] = <a class="code" href="a00020.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a>;
<a name="l00879"></a>00879    <span class="keywordflow">return</span> TRUE;
<a name="l00880"></a>00880 }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882 
<a name="l00887"></a>00887 U32   <a class="code" href="a00020.html#0a8beb16a074b07828fc725e0c0ae500" title="This function returns the space free in the selected FAT32 partition.">fat_read_fat32_FSInfo</a>( <span class="keywordtype">void</span> )
<a name="l00888"></a><a class="code" href="a00021.html#0a8beb16a074b07828fc725e0c0ae500">00888</a> {
<a name="l00889"></a>00889    U32 u32_nb_free_cluster;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891    <span class="comment">// Read FAT32 FSInfo Sector</span>
<a name="l00892"></a>00892    <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> - <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#d7fc62fd6868a846c0f242c6cf35fe60" title="Offset between the beginning of FAT and the FSInfo sector (only used by FAT32) (unit...">u16_offset_FSInfo</a>;
<a name="l00893"></a>00893    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( TRUE ))
<a name="l00894"></a>00894       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00895"></a>00895 
<a name="l00896"></a>00896    <span class="comment">//* Check signature</span>
<a name="l00897"></a>00897    <span class="comment">// offset 510-511, Signature</span>
<a name="l00898"></a>00898    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[510] != <a class="code" href="a00020.html#36f09355f7020d410cb43695cab680fa">FS_BR_SIGNATURE_LOW</a> )
<a name="l00899"></a>00899       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00900"></a>00900    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[511] != <a class="code" href="a00020.html#b4cd4bfc6a5baebc1d25bbc5d5db2c15">FS_BR_SIGNATURE_HIGH</a>)
<a name="l00901"></a>00901       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00902"></a>00902    <span class="comment">// offset 00-04, This lead signature</span>
<a name="l00903"></a>00903    <span class="keywordflow">if</span>( 0 != memcmp_code2ram( &amp;<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[0], <a class="code" href="a00021.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#0ab271becae152fb0b33ad5eb33ec22b">const_FSI_LeadSig</a>) ))
<a name="l00904"></a>00904       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00905"></a>00905    <span class="comment">// offset 004-483, reserved (fill with 0)</span>
<a name="l00906"></a>00906    <span class="comment">// offset 484-487, signature</span>
<a name="l00907"></a>00907    <span class="keywordflow">if</span>( 0 != memcmp_code2ram( &amp;<a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[484], <a class="code" href="a00021.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#71e0de07d391ec4f20a8a1bb4b446f90">const_FSI_StrucSig</a>)) )
<a name="l00908"></a>00908       <span class="keywordflow">return</span> 0xFFFFFFFF;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910    <span class="comment">//* Read value</span>
<a name="l00911"></a>00911    <span class="comment">// offset 488-491, free cluster count</span>
<a name="l00912"></a>00912    LSB0(u32_nb_free_cluster) = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[488];
<a name="l00913"></a>00913    LSB1(u32_nb_free_cluster) = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[489];
<a name="l00914"></a>00914    LSB2(u32_nb_free_cluster) = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[490];
<a name="l00915"></a>00915    LSB3(u32_nb_free_cluster) = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[491];
<a name="l00916"></a>00916    <span class="keywordflow">return</span> u32_nb_free_cluster;
<a name="l00917"></a>00917 }
<a name="l00918"></a>00918 <span class="preprocessor">#endif  // FS_FAT_32</span>
<a name="l00919"></a>00919 <span class="preprocessor"></span>
<a name="l00920"></a>00920 
<a name="l00928"></a>00928 Bool  <a class="code" href="a00021.html#ad6177926c645c867ea1d23c727d9097" title="This function cleans the reserved zone, FAT zone, and root dir zone.">fat_clean_zone</a>( Bool b_MBR )
<a name="l00929"></a><a class="code" href="a00021.html#ad6177926c645c867ea1d23c727d9097">00929</a> {
<a name="l00930"></a>00930    U16 u16_nb_sector_clean, u16_i;
<a name="l00931"></a>00931    _MEM_TYPE_SLOW_   U8 *ptr;
<a name="l00932"></a>00932 
<a name="l00933"></a>00933    <span class="comment">// Flush the internal cache before clear the cache</span>
<a name="l00934"></a>00934    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#578ab4800128cde17c0820a5027c1c06" title="This function flushs the sector cache on the memory if necessary.">fat_cache_flush</a>())
<a name="l00935"></a>00935       <span class="keywordflow">return</span> FALSE;
<a name="l00936"></a>00936    <a class="code" href="a00019.html#5948c1de515852418670d3fb8ae1e832" title="This function clears the sector cache.">fat_cache_clear</a>();
<a name="l00937"></a>00937 
<a name="l00938"></a>00938    <span class="comment">// remark: these zones are stored after the PBR and are continues</span>
<a name="l00939"></a>00939    <span class="comment">// Start after PBR</span>
<a name="l00940"></a>00940    <span class="keywordflow">if</span>( b_MBR )
<a name="l00941"></a>00941    {
<a name="l00942"></a>00942       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = 2; <span class="comment">// Jump MBR and PBR</span>
<a name="l00943"></a>00943    }<span class="keywordflow">else</span>{
<a name="l00944"></a>00944       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = 1; <span class="comment">// Jump only a PBR (no MBR create)</span>
<a name="l00945"></a>00945    }
<a name="l00946"></a>00946 
<a name="l00947"></a>00947    <span class="comment">// Compute reserved zone size and root size</span>
<a name="l00948"></a>00948    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l00949"></a>00949    {  <span class="comment">// FAT 32</span>
<a name="l00950"></a>00950       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>++;   <span class="comment">// Jump FAT32 FSInfo Sector</span>
<a name="l00951"></a>00951       <span class="comment">// root size = cluster size AND reserved zone = 32 - 2 (2 = PBR + FSInfo)</span>
<a name="l00952"></a>00952       u16_nb_sector_clean = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a> + 30;
<a name="l00953"></a>00953    }
<a name="l00954"></a>00954    <span class="keywordflow">else</span>
<a name="l00955"></a>00955    {  <span class="comment">// FAT 12 or 16</span>
<a name="l00956"></a>00956       <span class="comment">// root size = 512 entrys = 32 sectors AND reserved zone = 1 - 1(PBR)</span>
<a name="l00957"></a>00957       u16_nb_sector_clean = 32;
<a name="l00958"></a>00958    }
<a name="l00959"></a>00959    u16_nb_sector_clean += (<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>*2);  <span class="comment">// Add FAT size</span>
<a name="l00960"></a>00960 
<a name="l00961"></a>00961    <span class="comment">// loop to clean</span>
<a name="l00962"></a>00962    <span class="keywordflow">for</span>( ; u16_nb_sector_clean!=0; u16_nb_sector_clean-- )
<a name="l00963"></a>00963    {
<a name="l00964"></a>00964       <span class="comment">// To improve the format time</span>
<a name="l00965"></a>00965       <span class="comment">// We check if the sector is clean (0x00) instead of write a clean sector.</span>
<a name="l00966"></a>00966       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( TRUE ))
<a name="l00967"></a>00967          <span class="keywordflow">return</span> FALSE;
<a name="l00968"></a>00968       ptr = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>;
<a name="l00969"></a>00969       <span class="keywordflow">for</span>( u16_i=0; u16_i&lt;<a class="code" href="a00020.html#1f24fc24a15f2e52ecae58ae2d5dfbfc">FS_CACHE_SIZE</a>; u16_i++,ptr++ )
<a name="l00970"></a>00970       {
<a name="l00971"></a>00971          <span class="keywordflow">if</span>( 0x00 != *ptr )
<a name="l00972"></a>00972          {
<a name="l00973"></a>00973             <span class="comment">// Sector not clean then erase it</span>
<a name="l00974"></a>00974             <a class="code" href="a00019.html#5948c1de515852418670d3fb8ae1e832" title="This function clears the sector cache.">fat_cache_clear</a>();
<a name="l00975"></a>00975             <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l00976"></a>00976             <span class="keywordflow">break</span>;
<a name="l00977"></a>00977          }
<a name="l00978"></a>00978       }         
<a name="l00979"></a>00979       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>++;
<a name="l00980"></a>00980    }
<a name="l00981"></a>00981    <span class="keywordflow">return</span> TRUE;
<a name="l00982"></a>00982 }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984 
<a name="l00987"></a>00987 _CONST_TYPE_ U8 <a class="code" href="a00021.html#d7b8480b30e94480383a615e9304dee1">const_header_fat12</a>[] = {
<a name="l00988"></a><a class="code" href="a00021.html#d7b8480b30e94480383a615e9304dee1">00988</a>    0xF8,0xFF,0xFF                            <span class="comment">// reserved clusters 0 &amp; 1</span>
<a name="l00989"></a>00989    };
<a name="l00990"></a>00990 _CONST_TYPE_ U8 <a class="code" href="a00021.html#96762bd73caa7d1fdc8c92db0b777f1a">const_header_fat16</a>[] = {
<a name="l00991"></a><a class="code" href="a00021.html#96762bd73caa7d1fdc8c92db0b777f1a">00991</a>    0xF8,0xFF,0xFF,0xFF                       <span class="comment">// reserved clusters 0 &amp; 1</span>
<a name="l00992"></a>00992    };
<a name="l00993"></a>00993 _CONST_TYPE_ U8 <a class="code" href="a00021.html#94831debe0600f19945c3239dc3634e7">const_header_fat32</a>[] = {
<a name="l00994"></a><a class="code" href="a00021.html#94831debe0600f19945c3239dc3634e7">00994</a>    0xF8,0xFF,0xFF,0x0F,0xFF,0xFF,0xFF,0x0F   <span class="comment">// reserved clusters 0 &amp; 1</span>
<a name="l00995"></a>00995   ,0xFF,0xFF,0xFF,0x0F                       <span class="comment">// reserved clusters 2 for root directory</span>
<a name="l00996"></a>00996    };
<a name="l00998"></a>00998 
<a name="l00999"></a>00999 
<a name="l01005"></a>01005 Bool  <a class="code" href="a00021.html#6ab74fa9e68a4379a3ea33465d835277" title="This function initializes the fat one and two.">fat_initialize_fat</a>( <span class="keywordtype">void</span> )
<a name="l01006"></a><a class="code" href="a00021.html#6ab74fa9e68a4379a3ea33465d835277">01006</a> {
<a name="l01007"></a>01007    <span class="comment">// Init and reset the internal cache at the memory beginning</span>
<a name="l01008"></a>01008    <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a>;
<a name="l01009"></a>01009    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( FALSE ))
<a name="l01010"></a>01010       <span class="keywordflow">return</span> FALSE;
<a name="l01011"></a>01011    <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l01012"></a>01012 
<a name="l01013"></a>01013    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l01014"></a>01014    {
<a name="l01015"></a>01015       memcpy_code2ram( <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>, <a class="code" href="a00021.html#94831debe0600f19945c3239dc3634e7">const_header_fat32</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#94831debe0600f19945c3239dc3634e7">const_header_fat32</a>) );
<a name="l01016"></a>01016    }
<a name="l01017"></a>01017    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l01018"></a>01018    {
<a name="l01019"></a>01019       memcpy_code2ram( <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>, <a class="code" href="a00021.html#96762bd73caa7d1fdc8c92db0b777f1a">const_header_fat16</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#96762bd73caa7d1fdc8c92db0b777f1a">const_header_fat16</a>) );
<a name="l01020"></a>01020    }
<a name="l01021"></a>01021    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l01022"></a>01022    {
<a name="l01023"></a>01023       memcpy_code2ram( <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>, <a class="code" href="a00021.html#d7b8480b30e94480383a615e9304dee1">const_header_fat12</a>, <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#d7b8480b30e94480383a615e9304dee1">const_header_fat12</a>) );
<a name="l01024"></a>01024    }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026    <span class="comment">// Copy the first sector of FAT 1 in the first sector of FAT 2</span>
<a name="l01027"></a>01027    <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> + <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>;
<a name="l01028"></a>01028    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( FALSE ))
<a name="l01029"></a>01029       <span class="keywordflow">return</span> FALSE;
<a name="l01030"></a>01030    <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l01031"></a>01031    <span class="keywordflow">return</span> TRUE;
<a name="l01032"></a>01032 }
<a name="l01033"></a>01033 
<a name="l01034"></a>01034 
<a name="l01043"></a>01043 Bool  <a class="code" href="a00020.html#2ff43f97db7a5d76f46f4fb1b683d192" title="This function reads or writes a serial number.">fat_serialnumber</a>( Bool b_action , U8 _MEM_TYPE_SLOW_ *a_u8_sn )
<a name="l01044"></a><a class="code" href="a00021.html#2ff43f97db7a5d76f46f4fb1b683d192">01044</a> {
<a name="l01045"></a>01045    <span class="comment">// Compute PBR address</span>
<a name="l01046"></a>01046    <span class="keywordflow">if</span> ( <a class="code" href="a00020.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> || <a class="code" href="a00020.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l01047"></a>01047    {  <span class="comment">// FAT 12 &amp; 16 (BPB_ResvSecCnt must be ega to 1)</span>
<a name="l01048"></a>01048       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a>-1;
<a name="l01049"></a>01049    }
<a name="l01050"></a>01050    <span class="keywordflow">else</span>
<a name="l01051"></a>01051    {  <span class="comment">// FAT 32 (BPB_ResvSecCnt must be ega to 32)</span>
<a name="l01052"></a>01052       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a>-32;
<a name="l01053"></a>01053    }
<a name="l01054"></a>01054    <span class="comment">// Read PBR</span>
<a name="l01055"></a>01055    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( TRUE ))
<a name="l01056"></a>01056       <span class="keywordflow">return</span> FALSE;
<a name="l01057"></a>01057 
<a name="l01058"></a>01058    <span class="comment">// The serial is storaged at invert</span>
<a name="l01059"></a>01059    <span class="keywordflow">if</span>( b_action == <a class="code" href="a00024.html#030606a7731d280a91dd5b796e50804e">FS_SN_READ</a> )
<a name="l01060"></a>01060    {
<a name="l01061"></a>01061       <span class="comment">// Read serial number</span>
<a name="l01062"></a>01062       a_u8_sn[0] = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[42];
<a name="l01063"></a>01063       a_u8_sn[1] = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[41];
<a name="l01064"></a>01064       a_u8_sn[2] = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[40];
<a name="l01065"></a>01065       a_u8_sn[3] = <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[39];
<a name="l01066"></a>01066       <span class="keywordflow">return</span> TRUE;
<a name="l01067"></a>01067    }<span class="keywordflow">else</span>{
<a name="l01068"></a>01068       <span class="comment">// Write serial number</span>
<a name="l01069"></a>01069       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[42] = a_u8_sn[0];
<a name="l01070"></a>01070       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[41] = a_u8_sn[1];
<a name="l01071"></a>01071       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[40] = a_u8_sn[2];
<a name="l01072"></a>01072       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[39] = a_u8_sn[3];
<a name="l01073"></a>01073       <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l01074"></a>01074       <span class="keywordflow">return</span> <a class="code" href="a00019.html#578ab4800128cde17c0820a5027c1c06" title="This function flushs the sector cache on the memory if necessary.">fat_cache_flush</a>();
<a name="l01075"></a>01075    }
<a name="l01076"></a>01076 }
<a name="l01077"></a>01077 
<a name="l01078"></a>01078 
<a name="l01087"></a>01087 Bool  <a class="code" href="a00020.html#a03d2728f28964e1eb4d78c2bb831718" title="This function reads or writes a label in the partition.">fat_entry_label</a>( Bool b_action , <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_label )
<a name="l01088"></a><a class="code" href="a00021.html#a03d2728f28964e1eb4d78c2bb831718">01088</a> {
<a name="l01089"></a>01089    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01090"></a>01090    U8 u8_pos_name;
<a name="l01091"></a>01091    U8 u8_char;
<a name="l01092"></a>01092 
<a name="l01093"></a>01093    ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l01094"></a>01094 
<a name="l01095"></a>01095    <span class="keywordflow">if</span>( <a class="code" href="a00024.html#c1570dd392605e8ff8f7d4cb16487830">FS_LABEL_READ</a> == b_action)
<a name="l01096"></a>01096    {
<a name="l01097"></a>01097       <span class="keywordflow">if</span>( <a class="code" href="a00020.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> == ptr_entry[0] )           <span class="comment">// end of directory</span>
<a name="l01098"></a>01098       {
<a name="l01099"></a>01099          <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#33817136df196a5f0146574b4e1775b6" title="File entry empty.">FS_ERR_ENTRY_EMPTY</a>;
<a name="l01100"></a>01100          <span class="keywordflow">return</span> FALSE;
<a name="l01101"></a>01101       }
<a name="l01102"></a>01102       <span class="keywordflow">if</span>( <a class="code" href="a00024.html#4ed995c53b13fcf1694ae3ba6da61eba">FS_ATTR_VOLUME_ID</a> != ptr_entry[11])      <span class="comment">// no system label</span>
<a name="l01103"></a>01103       {
<a name="l01104"></a>01104          <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#934f48a8e1cb558d75ec00bbd242030d" title="File entry bad.">FS_ERR_ENTRY_BAD</a>;
<a name="l01105"></a>01105          <span class="keywordflow">return</span> FALSE;
<a name="l01106"></a>01106       }
<a name="l01107"></a>01107       <span class="keywordflow">if</span>( NULL == sz_label )
<a name="l01108"></a>01108          <span class="keywordflow">return</span> TRUE;
<a name="l01109"></a>01109       <span class="keywordflow">for</span>( u8_pos_name=0; u8_pos_name&lt;11; u8_pos_name++ )
<a name="l01110"></a>01110       {
<a name="l01111"></a>01111          u8_char = *ptr_entry;
<a name="l01112"></a>01112          <span class="keywordflow">if</span>( 0x20 == u8_char )
<a name="l01113"></a>01113             u8_char = 0;
<a name="l01114"></a>01114          *sz_label = u8_char;
<a name="l01115"></a>01115          <span class="keywordflow">if</span>( 0 == u8_char )
<a name="l01116"></a>01116             <span class="keywordflow">return</span> TRUE;                           <span class="comment">// Label readed</span>
<a name="l01117"></a>01117          ptr_entry++;
<a name="l01118"></a>01118          sz_label++;
<a name="l01119"></a>01119       }
<a name="l01120"></a>01120       *sz_label = 0;
<a name="l01121"></a>01121       <span class="keywordflow">return</span> TRUE;
<a name="l01122"></a>01122    }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124    <span class="keywordflow">if</span>( <a class="code" href="a00024.html#c5e191f04380ef238255929695f8efcb">FS_LABEL_WRITE</a> == b_action)
<a name="l01125"></a>01125    {
<a name="l01126"></a>01126       <span class="comment">// Autorize to write the label only on an empty entry or the system label entry</span>
<a name="l01127"></a>01127       <span class="keywordflow">if</span>( <a class="code" href="a00020.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> != ptr_entry[0] )           <span class="comment">// end of directory</span>
<a name="l01128"></a>01128       {
<a name="l01129"></a>01129          <span class="keywordflow">if</span>( <a class="code" href="a00024.html#4ed995c53b13fcf1694ae3ba6da61eba">FS_ATTR_VOLUME_ID</a> != ptr_entry[11])   <span class="comment">// no system label</span>
<a name="l01130"></a>01130          {
<a name="l01131"></a>01131             <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#934f48a8e1cb558d75ec00bbd242030d" title="File entry bad.">FS_ERR_ENTRY_BAD</a>;
<a name="l01132"></a>01132             <span class="keywordflow">return</span> FALSE;
<a name="l01133"></a>01133          }
<a name="l01134"></a>01134       }
<a name="l01135"></a>01135       <span class="keywordflow">if</span>( 0 == *sz_label )
<a name="l01136"></a>01136       {
<a name="l01137"></a>01137          <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#5ea145bbe1eb7413020b5e6b6f12a1ba" title="The name don&amp;#39;t corresponding at the filter name.">FS_ERR_NAME_INCORRECT</a>;
<a name="l01138"></a>01138          <span class="keywordflow">return</span> FALSE;
<a name="l01139"></a>01139       }
<a name="l01140"></a>01140       ptr_entry[11] = <a class="code" href="a00024.html#4ed995c53b13fcf1694ae3ba6da61eba">FS_ATTR_VOLUME_ID</a>;
<a name="l01141"></a>01141       <span class="keywordflow">for</span>( u8_pos_name=0; u8_pos_name&lt;11; u8_pos_name++ )
<a name="l01142"></a>01142       {
<a name="l01143"></a>01143          u8_char = *sz_label;
<a name="l01144"></a>01144          <span class="keywordflow">if</span>( (<span class="charliteral">'a'</span>&lt;=u8_char) &amp;&amp; (u8_char&lt;=<span class="charliteral">'z'</span>) )
<a name="l01145"></a>01145          {
<a name="l01146"></a>01146             u8_char -= (<span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>);                  <span class="comment">// Change to upper case</span>
<a name="l01147"></a>01147          }
<a name="l01148"></a>01148          <span class="keywordflow">if</span>( 0 == u8_char )
<a name="l01149"></a>01149          {
<a name="l01150"></a>01150             u8_char = 0x20;
<a name="l01151"></a>01151          }
<a name="l01152"></a>01152          *ptr_entry = u8_char;
<a name="l01153"></a>01153          ptr_entry++;
<a name="l01154"></a>01154          <span class="keywordflow">if</span>( 0x20 == u8_char )
<a name="l01155"></a>01155             <span class="keywordflow">continue</span>;
<a name="l01156"></a>01156          sz_label++;
<a name="l01157"></a>01157       }
<a name="l01158"></a>01158       <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l01159"></a>01159       <span class="keywordflow">return</span> <a class="code" href="a00019.html#578ab4800128cde17c0820a5027c1c06" title="This function flushs the sector cache on the memory if necessary.">fat_cache_flush</a>();
<a name="l01160"></a>01160    }
<a name="l01161"></a>01161    <span class="keywordflow">return</span> FALSE;                                   <span class="comment">// To delete the compilation warning</span>
<a name="l01162"></a>01162 }
<a name="l01163"></a>01163 <span class="preprocessor">#endif  // FS_LEVEL_FEATURES</span>
<a name="l01164"></a>01164 <span class="preprocessor"></span>
<a name="l01165"></a>01165 
<a name="l01166"></a>01166 <span class="preprocessor">#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES &amp; FSFEATURE_WRITE_COMPLET))</span>
<a name="l01180"></a>01180 <span class="preprocessor">Bool  fat_initialize_dir( void )</span>
<a name="l01181"></a><a class="code" href="a00021.html#9510bd193c1e70f2307c5b9b07078511">01181</a> <span class="preprocessor"></span>{
<a name="l01182"></a>01182    U8 u8_i;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184    <span class="comment">// Clear the cluster corresponding at directory</span>
<a name="l01185"></a>01185    <span class="keywordflow">if</span>( !<a class="code" href="a00020.html#6cc9ee9a14553be84990df27709f51a6" title="This function clears one cluster.">fat_clear_cluster</a>())
<a name="l01186"></a>01186       <span class="keywordflow">return</span> FALSE;
<a name="l01187"></a>01187    <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l01188"></a>01188    <span class="comment">// here, the internal cache is the first sector of the cluster</span>
<a name="l01189"></a>01189 
<a name="l01190"></a>01190    <span class="comment">// Create the dot "." entry, this one is a directory that points to itself</span>
<a name="l01191"></a>01191    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[0]=<span class="charliteral">'.'</span>;
<a name="l01192"></a>01192    <span class="keywordflow">for</span>( u8_i=1 ; u8_i&lt;11 ; u8_i++ )
<a name="l01193"></a>01193       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[u8_i]=<span class="charliteral">' '</span>;
<a name="l01194"></a>01194    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[11]=<a class="code" href="a00024.html#99004e3e756391a7ac1c4dde4db6864c">FS_ATTR_DIRECTORY</a>;
<a name="l01195"></a>01195    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[26]= LSB0( <a class="code" href="a00020.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#eaa27a06eca82fa0f65d848def8a4b87" title="First cluster of the selected file.">u32_cluster</a> );
<a name="l01196"></a>01196    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[27]= LSB1( <a class="code" href="a00020.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#eaa27a06eca82fa0f65d848def8a4b87" title="First cluster of the selected file.">u32_cluster</a> );
<a name="l01197"></a>01197    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[20]= LSB2( <a class="code" href="a00020.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#eaa27a06eca82fa0f65d848def8a4b87" title="First cluster of the selected file.">u32_cluster</a> );
<a name="l01198"></a>01198    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[21]= LSB3( <a class="code" href="a00020.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#eaa27a06eca82fa0f65d848def8a4b87" title="First cluster of the selected file.">u32_cluster</a> );
<a name="l01199"></a>01199    <span class="comment">// Create the dotdot ".." entry, this one points to the starting cluster of the parent directory</span>
<a name="l01200"></a>01200    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+0]=<span class="charliteral">'.'</span>;
<a name="l01201"></a>01201    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+1]=<span class="charliteral">'.'</span>;
<a name="l01202"></a>01202    <span class="keywordflow">for</span>( u8_i=2 ; u8_i&lt;11 ; u8_i++ )
<a name="l01203"></a>01203       <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+u8_i]=<span class="charliteral">' '</span>;
<a name="l01204"></a>01204    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+11]=<a class="code" href="a00024.html#99004e3e756391a7ac1c4dde4db6864c">FS_ATTR_DIRECTORY</a>;
<a name="l01205"></a>01205    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+26]= LSB0( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f" title="First cluster number of selected directory (0 for the root directory).">u32_cluster_sel_dir</a> );
<a name="l01206"></a>01206    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+27]= LSB1( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f" title="First cluster number of selected directory (0 for the root directory).">u32_cluster_sel_dir</a> );
<a name="l01207"></a>01207    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+20]= LSB2( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f" title="First cluster number of selected directory (0 for the root directory).">u32_cluster_sel_dir</a> );
<a name="l01208"></a>01208    <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a>+21]= LSB3( <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#ed8faad36e96ff2f422ddadd3740713f" title="First cluster number of selected directory (0 for the root directory).">u32_cluster_sel_dir</a> );
<a name="l01209"></a>01209 
<a name="l01210"></a>01210    <span class="keywordflow">return</span> TRUE;
<a name="l01211"></a>01211 }
<a name="l01212"></a>01212 <span class="preprocessor">#endif  // FS_LEVEL_FEATURES</span>
<a name="l01213"></a>01213 <span class="preprocessor"></span>
<a name="l01214"></a>01214 
<a name="l01221"></a>01221 <span class="keywordtype">void</span>  <a class="code" href="a00020.html#51041500c2e36ab39aad19b54e93d504" title="This function reads the information about a date.">fat_get_date</a>( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_date , Bool type_date )
<a name="l01222"></a><a class="code" href="a00021.html#51041500c2e36ab39aad19b54e93d504">01222</a> {
<a name="l01223"></a>01223    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01224"></a>01224 
<a name="l01225"></a>01225    ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l01226"></a>01226    <span class="keywordflow">if</span>( <a class="code" href="a00024.html#fbbd68bf71e1e73a9162dd04f3dec8fe">FS_DATE_LAST_WRITE</a> == type_date )
<a name="l01227"></a>01227    {
<a name="l01228"></a>01228       <a class="code" href="a00021.html#015e44f70b92d8b39e00ababfdb6bc24" title="This function translates a date FAT value to ascii string.">fat_translatedate_number_to_ascii</a>( sz_date , &amp;ptr_entry[22] , FALSE );
<a name="l01229"></a>01229    }
<a name="l01230"></a>01230    <span class="keywordflow">else</span>
<a name="l01231"></a>01231    {
<a name="l01232"></a>01232       <a class="code" href="a00021.html#015e44f70b92d8b39e00ababfdb6bc24" title="This function translates a date FAT value to ascii string.">fat_translatedate_number_to_ascii</a>( sz_date , &amp;ptr_entry[13] , TRUE );
<a name="l01233"></a>01233    }
<a name="l01234"></a>01234 }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236 
<a name="l01244"></a>01244 <span class="keywordtype">void</span>  <a class="code" href="a00021.html#015e44f70b92d8b39e00ababfdb6bc24" title="This function translates a date FAT value to ascii string.">fat_translatedate_number_to_ascii</a>( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_date , <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_date , Bool enable_ms )
<a name="l01245"></a><a class="code" href="a00021.html#015e44f70b92d8b39e00ababfdb6bc24">01245</a> {
<a name="l01246"></a>01246    <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> ptr_string_date;
<a name="l01247"></a>01247    U8 u8_i;
<a name="l01248"></a>01248    U8 msb_date, lsb_date, msb_time, lsb_time, u8_ms = 0;
<a name="l01249"></a>01249 
<a name="l01250"></a>01250    <span class="comment">// Read entry value of date and time</span>
<a name="l01251"></a>01251    <span class="keywordflow">if</span>( enable_ms )
<a name="l01252"></a>01252    {
<a name="l01253"></a>01253       u8_ms = *ptr_date;
<a name="l01254"></a>01254       ptr_date++;
<a name="l01255"></a>01255    }
<a name="l01256"></a>01256    lsb_time = *ptr_date;
<a name="l01257"></a>01257    ptr_date++;
<a name="l01258"></a>01258    msb_time = *ptr_date;
<a name="l01259"></a>01259    ptr_date++;
<a name="l01260"></a>01260    lsb_date = *ptr_date;
<a name="l01261"></a>01261    ptr_date++;
<a name="l01262"></a>01262    msb_date = *ptr_date;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264    <span class="comment">// Initialise the string with "1980000000000000" (Year = 1980 and other at 0)</span>
<a name="l01265"></a>01265    ptr_string_date = sz_date;
<a name="l01266"></a>01266    *ptr_string_date = <span class="charliteral">'1'</span>;
<a name="l01267"></a>01267    ptr_string_date++;
<a name="l01268"></a>01268    *ptr_string_date = <span class="charliteral">'9'</span>;
<a name="l01269"></a>01269    ptr_string_date++;
<a name="l01270"></a>01270    *ptr_string_date = <span class="charliteral">'8'</span>;
<a name="l01271"></a>01271    ptr_string_date++;
<a name="l01272"></a>01272    <span class="keywordflow">for</span>( u8_i=(15-2) ; u8_i!=0 ; u8_i-- )
<a name="l01273"></a>01273    {
<a name="l01274"></a>01274       *ptr_string_date = <span class="charliteral">'0'</span>;
<a name="l01275"></a>01275       ptr_string_date++;
<a name="l01276"></a>01276    }
<a name="l01277"></a>01277 
<a name="l01278"></a>01278    <span class="comment">// Get the year</span>
<a name="l01279"></a>01279    <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( sz_date, 4 , msb_date&gt;&gt;1 );
<a name="l01280"></a>01280 
<a name="l01281"></a>01281    <span class="comment">// Get the month</span>
<a name="l01282"></a>01282    <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( &amp;sz_date[4] , 2 , ((msb_date &amp; 0x01)&lt;&lt;3) + (lsb_date&gt;&gt;5) );
<a name="l01283"></a>01283 
<a name="l01284"></a>01284    <span class="comment">// Get the day</span>
<a name="l01285"></a>01285    <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( &amp;sz_date[6] , 2 , lsb_date &amp; 0x1F );
<a name="l01286"></a>01286 
<a name="l01287"></a>01287    <span class="comment">// Get the hour</span>
<a name="l01288"></a>01288    <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( &amp;sz_date[8] , 2 , msb_time &gt;&gt; (11-8) );
<a name="l01289"></a>01289 
<a name="l01290"></a>01290    <span class="comment">// Get the minute</span>
<a name="l01291"></a>01291    <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( &amp;sz_date[10] , 2 , ((msb_time &amp; 0x07)&lt;&lt;3) + (lsb_time&gt;&gt;5) );
<a name="l01292"></a>01292 
<a name="l01293"></a>01293    <span class="comment">// Get the seconde</span>
<a name="l01294"></a>01294    <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( &amp;sz_date[12] , 2 , (lsb_time &amp; 0x1F)&lt;&lt;1 );
<a name="l01295"></a>01295    <span class="keywordflow">if</span>( 99 &lt; u8_ms )
<a name="l01296"></a>01296    {
<a name="l01297"></a>01297      <span class="comment">// Add one seconde</span>
<a name="l01298"></a>01298      <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( &amp;sz_date[12] , 2 , 1 );
<a name="l01299"></a>01299      u8_ms -= 100;
<a name="l01300"></a>01300    }
<a name="l01301"></a>01301 
<a name="l01302"></a>01302    <span class="comment">// Get the miliseconde</span>
<a name="l01303"></a>01303    <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( &amp;sz_date[14] , 2 , u8_ms );
<a name="l01304"></a>01304 }
<a name="l01305"></a>01305 
<a name="l01306"></a>01306 
<a name="l01317"></a>01317 <span class="keywordtype">void</span>  <a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b" title="This function translates a digital number to a ASCII number.">fat_translate_number_to_ascii</a>( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_ascii_number, U8 u8_size_number_ascii, U8 u8_nb_increment )
<a name="l01318"></a><a class="code" href="a00021.html#1a3ce899100c1b2a7798140852d9f22b">01318</a> {
<a name="l01319"></a>01319    <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> ptr_sz_ascii_number;
<a name="l01320"></a>01320 
<a name="l01321"></a>01321    u8_size_number_ascii--;
<a name="l01322"></a>01322 
<a name="l01323"></a>01323    <span class="keywordflow">for</span>( ; u8_nb_increment != 0 ; u8_nb_increment-- )
<a name="l01324"></a>01324    {
<a name="l01325"></a>01325       ptr_sz_ascii_number = sz_ascii_number + u8_size_number_ascii;
<a name="l01326"></a>01326       ptr_sz_ascii_number[0]++;
<a name="l01327"></a>01327       <span class="keywordflow">while</span>( (<span class="charliteral">'9'</span>+1) == *ptr_sz_ascii_number )
<a name="l01328"></a>01328       {
<a name="l01329"></a>01329          *ptr_sz_ascii_number = <span class="charliteral">'0'</span>;
<a name="l01330"></a>01330          ptr_sz_ascii_number--;
<a name="l01331"></a>01331          ptr_sz_ascii_number[0]++;
<a name="l01332"></a>01332       }
<a name="l01333"></a>01333    }
<a name="l01334"></a>01334 }
<a name="l01335"></a>01335 
<a name="l01336"></a>01336 
<a name="l01337"></a>01337 <span class="preprocessor">#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES &amp; FSFEATURE_WRITE_COMPLET))</span>
<a name="l01348"></a>01348 <span class="preprocessor">void  fat_set_date( const FS_STRING sz_date , Bool type_date )</span>
<a name="l01349"></a><a class="code" href="a00021.html#838253d384d03898e6fcb2b3a7687e43">01349</a> <span class="preprocessor"></span>{
<a name="l01350"></a>01350    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01351"></a>01351 
<a name="l01352"></a>01352    <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l01353"></a>01353    ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l01354"></a>01354 
<a name="l01355"></a>01355    <span class="keywordflow">if</span>( <a class="code" href="a00024.html#fbbd68bf71e1e73a9162dd04f3dec8fe">FS_DATE_LAST_WRITE</a> == type_date )
<a name="l01356"></a>01356    {
<a name="l01357"></a>01357       <a class="code" href="a00021.html#f2d2b930b3953ad1cfc996de5970a138" title="This function translates a date ascii string to date FAT value.">fat_translatedate_ascii_to_number</a>( sz_date , &amp;ptr_entry[22] , FALSE );
<a name="l01358"></a>01358    }
<a name="l01359"></a>01359    <span class="keywordflow">else</span>
<a name="l01360"></a>01360    {
<a name="l01361"></a>01361       <a class="code" href="a00021.html#f2d2b930b3953ad1cfc996de5970a138" title="This function translates a date ascii string to date FAT value.">fat_translatedate_ascii_to_number</a>( sz_date , &amp;ptr_entry[13] , TRUE );
<a name="l01362"></a>01362    }
<a name="l01363"></a>01363 }
<a name="l01364"></a>01364 
<a name="l01365"></a>01365 
<a name="l01377"></a>01377 <span class="keywordtype">void</span>  <a class="code" href="a00021.html#f2d2b930b3953ad1cfc996de5970a138" title="This function translates a date ascii string to date FAT value.">fat_translatedate_ascii_to_number</a>( <span class="keyword">const</span> <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_date , <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_date , Bool enable_ms )
<a name="l01378"></a><a class="code" href="a00021.html#f2d2b930b3953ad1cfc996de5970a138">01378</a> {
<a name="l01379"></a>01379    U8 u8_tmp;
<a name="l01380"></a>01380    U8 msb_date, lsb_date, msb_time, lsb_time;
<a name="l01381"></a>01381 
<a name="l01382"></a>01382    <span class="comment">// Set the year</span>
<a name="l01383"></a>01383    msb_date  = ((U8)(<a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>( sz_date , 4 )-1980))&lt;&lt;1;
<a name="l01384"></a>01384 
<a name="l01385"></a>01385    <span class="comment">// Set the month</span>
<a name="l01386"></a>01386    u8_tmp    = (U8)<a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>( &amp;sz_date[4] , 2 );
<a name="l01387"></a>01387    msb_date |= (u8_tmp &gt;&gt; 3);
<a name="l01388"></a>01388    lsb_date  = (u8_tmp &lt;&lt; 5);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390    <span class="comment">// Set the day</span>
<a name="l01391"></a>01391    lsb_date |= (U8)<a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>( &amp;sz_date[6] , 2 );
<a name="l01392"></a>01392 
<a name="l01393"></a>01393    <span class="comment">// Set the hour</span>
<a name="l01394"></a>01394    msb_time  = ((U8)<a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>( &amp;sz_date[8] , 2 )) &lt;&lt; (11-8);
<a name="l01395"></a>01395 
<a name="l01396"></a>01396    <span class="comment">// Set the minute</span>
<a name="l01397"></a>01397    u8_tmp    = (U8)<a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>( &amp;sz_date[10] , 2 );
<a name="l01398"></a>01398    msb_time |= (u8_tmp &gt;&gt; 3);
<a name="l01399"></a>01399    lsb_time  = (u8_tmp &lt;&lt; 5);
<a name="l01400"></a>01400 
<a name="l01401"></a>01401    <span class="comment">// Set the seconde</span>
<a name="l01402"></a>01402    u8_tmp    = (U8)<a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>( &amp;sz_date[12] , 2 );
<a name="l01403"></a>01403    lsb_time |= (u8_tmp &gt;&gt; 1);
<a name="l01404"></a>01404 
<a name="l01405"></a>01405    <span class="comment">// Set the miliseconde</span>
<a name="l01406"></a>01406    <span class="keywordflow">if</span>( enable_ms )
<a name="l01407"></a>01407    {
<a name="l01408"></a>01408       <span class="comment">// check if the seconde time is %2</span>
<a name="l01409"></a>01409       <span class="keywordflow">if</span>( u8_tmp &amp; 0x01 )
<a name="l01410"></a>01410       {  <span class="comment">// it isn't %2</span>
<a name="l01411"></a>01411          u8_tmp = 100;  <span class="comment">// add one seconde</span>
<a name="l01412"></a>01412       }
<a name="l01413"></a>01413       <span class="keywordflow">else</span>
<a name="l01414"></a>01414       {
<a name="l01415"></a>01415          u8_tmp = 0;    <span class="comment">// no more seconde</span>
<a name="l01416"></a>01416       }
<a name="l01417"></a>01417       *ptr_date = u8_tmp + (U8)<a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>( &amp;sz_date[14] , 2 );
<a name="l01418"></a>01418       ptr_date++;
<a name="l01419"></a>01419    }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421    <span class="comment">// Record value</span>
<a name="l01422"></a>01422    ptr_date[0] = lsb_time;
<a name="l01423"></a>01423    ptr_date[1] = msb_time;
<a name="l01424"></a>01424    ptr_date[2] = lsb_date;
<a name="l01425"></a>01425    ptr_date[3] = msb_date;
<a name="l01426"></a>01426 }
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 
<a name="l01440"></a>01440 U16   <a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424" title="This function translates a ASCII number to a digital number.">fat_translate_ascii_to_number</a>( <span class="keyword">const</span> <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_ascii_number, U8 u8_size_number_ascii  )
<a name="l01441"></a><a class="code" href="a00021.html#f138eb34db69daa5d51e33d130d85424">01441</a> {
<a name="l01442"></a>01442    U8 sz_ascii_number_copy[4];
<a name="l01443"></a>01443    U8 _MEM_TYPE_FAST_ *ptr_sz_ascii_number;
<a name="l01444"></a>01444    U8 u8_i;
<a name="l01445"></a>01445    U16 u16_number;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447    <span class="keywordflow">for</span>( u8_i=0; u8_i &lt; u8_size_number_ascii; u8_i++ )
<a name="l01448"></a>01448    {
<a name="l01449"></a>01449       sz_ascii_number_copy[u8_i] = sz_ascii_number[u8_i];
<a name="l01450"></a>01450    }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452    u16_number=0;
<a name="l01453"></a>01453 
<a name="l01454"></a>01454    <span class="keywordflow">while</span>( 1 )
<a name="l01455"></a>01455    {
<a name="l01456"></a>01456       <span class="comment">// Check if it is the end of ascii number (= "0...0")</span>
<a name="l01457"></a>01457       ptr_sz_ascii_number = sz_ascii_number_copy;
<a name="l01458"></a>01458       <span class="keywordflow">for</span>( u8_i = u8_size_number_ascii; u8_i !=0; u8_i-- )
<a name="l01459"></a>01459       {
<a name="l01460"></a>01460          <span class="keywordflow">if</span>( <span class="charliteral">'0'</span> != *ptr_sz_ascii_number )
<a name="l01461"></a>01461          {
<a name="l01462"></a>01462             <span class="keywordflow">break</span>;
<a name="l01463"></a>01463          }
<a name="l01464"></a>01464          ptr_sz_ascii_number++;
<a name="l01465"></a>01465       }
<a name="l01466"></a>01466       <span class="keywordflow">if</span>( 0 == u8_i)
<a name="l01467"></a>01467          <span class="keywordflow">return</span> u16_number;
<a name="l01468"></a>01468 
<a name="l01469"></a>01469       <span class="comment">// Decrement the number</span>
<a name="l01470"></a>01470       ptr_sz_ascii_number = sz_ascii_number_copy + u8_size_number_ascii -1;
<a name="l01471"></a>01471       u16_number++;
<a name="l01472"></a>01472       ptr_sz_ascii_number[0]--;
<a name="l01473"></a>01473       <span class="keywordflow">while</span>( (<span class="charliteral">'0'</span>-1) == ptr_sz_ascii_number[0] )
<a name="l01474"></a>01474       {
<a name="l01475"></a>01475          *ptr_sz_ascii_number = <span class="charliteral">'9'</span>;
<a name="l01476"></a>01476          ptr_sz_ascii_number--;
<a name="l01477"></a>01477          ptr_sz_ascii_number[0]--;
<a name="l01478"></a>01478       }
<a name="l01479"></a>01479    }
<a name="l01480"></a>01480 }
<a name="l01481"></a>01481 <span class="preprocessor">#endif  // FS_LEVEL_FEATURES</span>
<a name="l01482"></a>01482 <span class="preprocessor"></span>
<a name="l01483"></a>01483 
<a name="l01484"></a>01484 
<a name="l01485"></a>01485 <span class="preprocessor">#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES &amp; FSFEATURE_WRITE))</span>
<a name="l01499"></a>01499 <span class="preprocessor">Bool  fat_create_entry_file_name( FS_STRING sz_name )</span>
<a name="l01500"></a><a class="code" href="a00021.html#da2110d711208b46e93eb269da40bdf1">01500</a> <span class="preprocessor"></span>{
<a name="l01501"></a>01501    U8 u8_i, u8_nb;
<a name="l01502"></a>01502    U8 u8_crc, u8_nb_entry;
<a name="l01503"></a>01503 
<a name="l01504"></a>01504    <span class="comment">// Compute the number of entry for this name</span>
<a name="l01505"></a>01505    u8_nb_entry = <a class="code" href="a00021.html#8849a8388de3f116fd53fd9ec07747b2" title="This function checks the character in name AND computes the number of entry file...">fat_check_name</a>( sz_name  );
<a name="l01506"></a>01506    <span class="keywordflow">if</span>( 0 == u8_nb_entry )
<a name="l01507"></a>01507       <span class="keywordflow">return</span> FALSE;
<a name="l01508"></a>01508 
<a name="l01509"></a>01509    <span class="comment">// Search a unik short entry</span>
<a name="l01510"></a>01510    u8_nb = <a class="code" href="a00021.html#24d01b29254a31c7b331935fd8288037" title="This function searchs an unique short name.">fat_find_short_entry_name</a>( sz_name  );
<a name="l01511"></a>01511    <span class="keywordflow">if</span>( 0 == u8_nb )
<a name="l01512"></a>01512    {
<a name="l01513"></a>01513       <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#620feae4af460b0f591356b6408e7b45" title="The file is already existed.">FS_ERR_FILE_EXIST</a>;
<a name="l01514"></a>01514       <span class="keywordflow">return</span> FALSE;  <span class="comment">// All short name exist</span>
<a name="l01515"></a>01515    }
<a name="l01516"></a>01516    
<a name="l01517"></a>01517    <span class="comment">// Alloc a space for entrys</span>
<a name="l01518"></a>01518    <span class="keywordflow">if</span>( !<a class="code" href="a00021.html#a2b4dadfd961b4547fd67f7ebe8a5c5d" title="This function allocs a number of entry in a current directory.">fat_alloc_entry_free</a>( u8_nb_entry ))
<a name="l01519"></a>01519       <span class="keywordflow">return</span> FALSE;
<a name="l01520"></a>01520    <span class="comment">// Remark: here the pointer of entry is on the last free entry of new space allocated</span>
<a name="l01521"></a>01521 
<a name="l01522"></a>01522    <span class="comment">// Add short name entry</span>
<a name="l01523"></a>01523    u8_crc = <a class="code" href="a00021.html#49163f06665633236c432aa1a1163f01" title="This function creates a short name in the internal cache sector OR in a string.">fat_create_short_entry_name</a>( sz_name , 0 , u8_nb, FALSE  );
<a name="l01524"></a>01524    u8_nb_entry--;
<a name="l01525"></a>01525 
<a name="l01526"></a>01526    <span class="comment">// For each long name entry</span>
<a name="l01527"></a>01527    <span class="keywordflow">for</span>( u8_i=1 ; u8_i&lt;=u8_nb_entry ; u8_i++ )
<a name="l01528"></a>01528    {
<a name="l01529"></a>01529       <span class="comment">// Go to previous entry</span>
<a name="l01530"></a>01530       <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>--;
<a name="l01531"></a>01531       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#1a35321a99150ba643f87cb6c79ec3e5" title="This function fill the internal cache with a sector from current directory.">fat_read_dir</a>())
<a name="l01532"></a>01532          <span class="keywordflow">return</span> FALSE;
<a name="l01533"></a>01533       <span class="comment">// Write a long name entry</span>
<a name="l01534"></a>01534       <span class="keywordflow">if</span>( u8_i == u8_nb_entry )
<a name="l01535"></a>01535       {
<a name="l01536"></a>01536          u8_i += <a class="code" href="a00020.html#bf0fa999d28907c3742656b6407aca78">FS_ENTRY_LFN_LAST</a>;
<a name="l01537"></a>01537       }
<a name="l01538"></a>01538       <a class="code" href="a00021.html#70a6be69645d22685e0ec6b52b93d9b2" title="This function creates a long name entry.">fat_create_long_name_entry</a>( sz_name , u8_crc , u8_i );
<a name="l01539"></a>01539       sz_name += <a class="code" href="a00020.html#bbdca2b90701f373bf6c865c88c99697">FS_SIZE_LFN_ENTRY</a>*(<a class="code" href="a00020.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01540"></a>01540   }
<a name="l01541"></a>01541   <span class="comment">// Go back to the short name entry</span>
<a name="l01542"></a>01542   <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a> += u8_nb_entry;
<a name="l01543"></a>01543   <span class="keywordflow">return</span> TRUE;
<a name="l01544"></a>01544 }
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 
<a name="l01557"></a>01557 <span class="keywordtype">void</span>  <a class="code" href="a00021.html#70a6be69645d22685e0ec6b52b93d9b2" title="This function creates a long name entry.">fat_create_long_name_entry</a>( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_name , U8 u8_crc , U8 u8_id  )
<a name="l01558"></a><a class="code" href="a00021.html#70a6be69645d22685e0ec6b52b93d9b2">01558</a> {
<a name="l01559"></a>01559    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01560"></a>01560    Bool b_end_of_name = FALSE;
<a name="l01561"></a>01561 
<a name="l01562"></a>01562    <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l01563"></a>01563    ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l01564"></a>01564    *ptr_entry = u8_id;
<a name="l01565"></a>01565    ptr_entry++;   <span class="comment">// The long name start at offset 1 of the entry file</span>
<a name="l01566"></a>01566 
<a name="l01567"></a>01567    <span class="keywordflow">for</span>( u8_id=1; u8_id&lt;<a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a> ; u8_id++ , ptr_entry++ )
<a name="l01568"></a>01568    {
<a name="l01569"></a>01569       <span class="comment">// fields with no character</span>
<a name="l01570"></a>01570       <span class="keywordflow">if</span>( 11 == u8_id)
<a name="l01571"></a>01571       {
<a name="l01572"></a>01572          *ptr_entry = <a class="code" href="a00024.html#1aa64d79e89a455b62036d2230fd718d">FS_ATTR_LFN_ENTRY</a>;  <span class="comment">// attribut field</span>
<a name="l01573"></a>01573          <span class="keywordflow">continue</span>;
<a name="l01574"></a>01574       }
<a name="l01575"></a>01575       <span class="keywordflow">if</span>( (12 == u8_id)
<a name="l01576"></a>01576       ||  (26 == u8_id)
<a name="l01577"></a>01577       ||  (27 == u8_id) )
<a name="l01578"></a>01578       {
<a name="l01579"></a>01579          <span class="comment">// Reserved field</span>
<a name="l01580"></a>01580          <span class="comment">// *ptr_entry = 0x00;            // No necessary because the cache must be clean</span>
<a name="l01581"></a>01581          <span class="keywordflow">continue</span>;
<a name="l01582"></a>01582       }
<a name="l01583"></a>01583       <span class="keywordflow">if</span>( 13 == u8_id)
<a name="l01584"></a>01584       {
<a name="l01585"></a>01585          *ptr_entry = u8_crc;             <span class="comment">// CRC field</span>
<a name="l01586"></a>01586          <span class="keywordflow">continue</span>;
<a name="l01587"></a>01587       }
<a name="l01588"></a>01588 
<a name="l01589"></a>01589       <span class="comment">// fields with a character</span>
<a name="l01590"></a>01590       <span class="keywordflow">if</span>( !b_end_of_name )
<a name="l01591"></a>01591       {
<a name="l01592"></a>01592          U16 u16_tmp;
<a name="l01593"></a>01593          <span class="keywordflow">if</span>( <a class="code" href="a00020.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a> )
<a name="l01594"></a>01594          {
<a name="l01595"></a>01595             u16_tmp = ((<a class="code" href="a00024.html#4b07eeef6c66c629ec6708f8eee35f58">FS_STR_UNICODE</a>)sz_name)[0];
<a name="l01596"></a>01596          }<span class="keywordflow">else</span>{
<a name="l01597"></a>01597             u16_tmp = sz_name[0];
<a name="l01598"></a>01598          }
<a name="l01599"></a>01599          <span class="keywordflow">if</span>((<span class="charliteral">'\\'</span> == u16_tmp )
<a name="l01600"></a>01600          || (<span class="charliteral">'/'</span>  == u16_tmp ) )
<a name="l01601"></a>01601          {  <span class="comment">// end of name</span>
<a name="l01602"></a>01602             u16_tmp = 0;                  <span class="comment">// Set a end of name flag</span>
<a name="l01603"></a>01603          }
<a name="l01604"></a>01604          <span class="keywordflow">if</span>( 0 == u16_tmp )
<a name="l01605"></a>01605          {
<a name="l01606"></a>01606             b_end_of_name = TRUE;
<a name="l01607"></a>01607          }
<a name="l01608"></a>01608          *ptr_entry = LSB(u16_tmp);
<a name="l01609"></a>01609          ptr_entry++;
<a name="l01610"></a>01610          *ptr_entry = MSB(u16_tmp);
<a name="l01611"></a>01611          u8_id++;
<a name="l01612"></a>01612          sz_name += (<a class="code" href="a00020.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01613"></a>01613       }
<a name="l01614"></a>01614       <span class="keywordflow">else</span>
<a name="l01615"></a>01615       {  <span class="comment">// end of name</span>
<a name="l01616"></a>01616          *ptr_entry = 0xFF;               <span class="comment">// Padding mandatory</span>
<a name="l01617"></a>01617       }
<a name="l01618"></a>01618    } <span class="comment">// end of loop</span>
<a name="l01619"></a>01619 }
<a name="l01620"></a>01620 
<a name="l01621"></a>01621 
<a name="l01632"></a>01632 U8    <a class="code" href="a00021.html#49163f06665633236c432aa1a1163f01" title="This function creates a short name in the internal cache sector OR in a string.">fat_create_short_entry_name</a>( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_name , <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> short_name , U8 nb , Bool mode  )
<a name="l01633"></a><a class="code" href="a00021.html#49163f06665633236c432aa1a1163f01">01633</a> {
<a name="l01634"></a>01634    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry = 0;
<a name="l01635"></a>01635    U8 u8_i, u8_step, character;
<a name="l01636"></a>01636    U8 crc;
<a name="l01637"></a>01637    U8 nb_digit;
<a name="l01638"></a>01638 
<a name="l01639"></a>01639    <span class="keywordflow">if</span>( !mode )
<a name="l01640"></a>01640    {
<a name="l01641"></a>01641       <span class="comment">// Modify internal cache to create short name entry in the current entry</span>
<a name="l01642"></a>01642       <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l01643"></a>01643       <span class="comment">// Get pointer on current entry</span>
<a name="l01644"></a>01644       ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l01645"></a>01645    }
<a name="l01646"></a>01646 
<a name="l01647"></a>01647    <span class="comment">// Compute the digit number</span>
<a name="l01648"></a>01648    <span class="keywordflow">if</span>( nb &lt; 10 )        nb_digit = 1;
<a name="l01649"></a>01649    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( nb &lt; 100 )  nb_digit = 2;
<a name="l01650"></a>01650    <span class="keywordflow">else</span>                 nb_digit = 3;
<a name="l01651"></a>01651    
<a name="l01652"></a>01652    crc = u8_i = 0;
<a name="l01653"></a>01653    u8_step = 1;
<a name="l01654"></a>01654    <span class="keywordflow">while</span>( 1 )
<a name="l01655"></a>01655    {
<a name="l01656"></a>01656       <span class="keywordflow">if</span>( <a class="code" href="a00020.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a> )
<a name="l01657"></a>01657       {
<a name="l01658"></a>01658          character = ((<a class="code" href="a00024.html#4b07eeef6c66c629ec6708f8eee35f58">FS_STR_UNICODE</a>)sz_name)[0];
<a name="l01659"></a>01659       }<span class="keywordflow">else</span>{
<a name="l01660"></a>01660          character = sz_name[0];
<a name="l01661"></a>01661       }
<a name="l01662"></a>01662 
<a name="l01663"></a>01663       <span class="keywordflow">if</span>( 1 == u8_step )
<a name="l01664"></a>01664       {  <span class="comment">// step 1 = translate the name</span>
<a name="l01665"></a>01665          <span class="keywordflow">if</span>( ((<a class="code" href="a00020.html#18e4c969985c697213c58a67e7c20795">FS_SIZE_SFNAME_WITHOUT_EXT</a>-(1+nb_digit)) == u8_i)    <span class="comment">// name field is full (-2 for "~1")</span>
<a name="l01666"></a>01666          ||  (<span class="charliteral">'.'</span>    == character)                       <span class="comment">// is the end of name without extension</span>
<a name="l01667"></a>01667          ||  <a class="code" href="a00019.html#452e159ed5e2a4d8ea88f0515a3a6e10" title="Check end of name.">fat_check_eof_name</a>(character)            )  <span class="comment">// is the end of name</span>
<a name="l01668"></a>01668          {
<a name="l01669"></a>01669             u8_step++;                                   <span class="comment">// go to next step</span>
<a name="l01670"></a>01670             <span class="keywordflow">continue</span>;
<a name="l01671"></a>01671          }
<a name="l01672"></a>01672       }
<a name="l01673"></a>01673       <span class="keywordflow">if</span>( 8 == u8_step )
<a name="l01674"></a>01674       {  <span class="comment">// step 8 = translate the extension</span>
<a name="l01675"></a>01675          <span class="keywordflow">if</span>( (u8_i == <a class="code" href="a00020.html#69da5456f1f42a68c03ac860e33ac75b">FS_SIZE_SFNAME</a>)                    <span class="comment">// name field is full</span>
<a name="l01676"></a>01676          ||  <a class="code" href="a00019.html#452e159ed5e2a4d8ea88f0515a3a6e10" title="Check end of name.">fat_check_eof_name</a>(character)            )  <span class="comment">// is the end of name</span>
<a name="l01677"></a>01677          {
<a name="l01678"></a>01678             u8_step++;                                   <span class="comment">// go to next step</span>
<a name="l01679"></a>01679             <span class="keywordflow">continue</span>;
<a name="l01680"></a>01680          }
<a name="l01681"></a>01681       }
<a name="l01682"></a>01682       <span class="keywordflow">if</span>( (1==u8_step) || (8==u8_step) )
<a name="l01683"></a>01683       {  <span class="comment">// steps to translate name</span>
<a name="l01684"></a>01684          character = <a class="code" href="a00021.html#bb2561113110b35fac032431243f8bb0" title="This function translates the character to autorized short name character.">fat_translate_char_shortname</a>( character );
<a name="l01685"></a>01685          sz_name += (<a class="code" href="a00020.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01686"></a>01686          <span class="keywordflow">if</span>( 0 == character )
<a name="l01687"></a>01687          {
<a name="l01688"></a>01688             <span class="keywordflow">continue</span>;                                    <span class="comment">// Bad character, ignore this one</span>
<a name="l01689"></a>01689          }
<a name="l01690"></a>01690       }
<a name="l01691"></a>01691       <span class="keywordflow">if</span>( 7 == u8_step )
<a name="l01692"></a>01692       {  <span class="comment">// step 5 = find character '.'</span>
<a name="l01693"></a>01693          <span class="keywordflow">if</span>( (<span class="charliteral">'.'</span>    == character)                       <span class="comment">// is the end of name without extension</span>
<a name="l01694"></a>01694          ||  <a class="code" href="a00019.html#452e159ed5e2a4d8ea88f0515a3a6e10" title="Check end of name.">fat_check_eof_name</a>(character)            )  <span class="comment">// is the end of name</span>
<a name="l01695"></a>01695          {
<a name="l01696"></a>01696             u8_step++;                                   <span class="comment">// go to next step</span>
<a name="l01697"></a>01697          } <span class="keywordflow">else</span> {
<a name="l01698"></a>01698             sz_name += (<a class="code" href="a00020.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01699"></a>01699          }
<a name="l01700"></a>01700          <span class="keywordflow">continue</span>;                                       <span class="comment">// this step don't add a character in the short name</span>
<a name="l01701"></a>01701       }
<a name="l01702"></a>01702       <span class="keywordflow">if</span>( 6 == u8_step )
<a name="l01703"></a>01703       {  <span class="comment">// step 4 = add padding</span>
<a name="l01704"></a>01704          <span class="keywordflow">if</span>( u8_i == <a class="code" href="a00020.html#18e4c969985c697213c58a67e7c20795">FS_SIZE_SFNAME_WITHOUT_EXT</a> )        <span class="comment">// end of field name without extension</span>
<a name="l01705"></a>01705          {
<a name="l01706"></a>01706             u8_step++;                                   <span class="comment">// go to next step</span>
<a name="l01707"></a>01707             <span class="keywordflow">continue</span>;
<a name="l01708"></a>01708          }
<a name="l01709"></a>01709          character = <span class="charliteral">' '</span>;
<a name="l01710"></a>01710       }
<a name="l01711"></a>01711       <span class="keywordflow">if</span>( 9 == u8_step )
<a name="l01712"></a>01712       {  <span class="comment">// step 7 = add padding in extension name</span>
<a name="l01713"></a>01713          <span class="keywordflow">if</span>( u8_i == <a class="code" href="a00020.html#69da5456f1f42a68c03ac860e33ac75b">FS_SIZE_SFNAME</a> )                    <span class="comment">// end of field name with extension</span>
<a name="l01714"></a>01714          {
<a name="l01715"></a>01715             <span class="keywordflow">break</span>;                                       <span class="comment">// end of loop while(1)</span>
<a name="l01716"></a>01716          }
<a name="l01717"></a>01717          character = <span class="charliteral">' '</span>;
<a name="l01718"></a>01718       }
<a name="l01719"></a>01719       <span class="keywordflow">if</span>( 5 == u8_step )
<a name="l01720"></a>01720       {  <span class="comment">// step 4 = add unit 1 of number</span>
<a name="l01721"></a>01721          character = <span class="charliteral">'0'</span>+(nb%10);
<a name="l01722"></a>01722          u8_step++;                                      <span class="comment">// go to next step</span>
<a name="l01723"></a>01723       }
<a name="l01724"></a>01724       <span class="keywordflow">if</span>( 4 == u8_step )
<a name="l01725"></a>01725       {  <span class="comment">// step 3 = add unit 10 of number</span>
<a name="l01726"></a>01726          character = <span class="charliteral">'0'</span>+((nb%100)/10);
<a name="l01727"></a>01727          u8_step++;                                      <span class="comment">// go to next step</span>
<a name="l01728"></a>01728       }
<a name="l01729"></a>01729       <span class="keywordflow">if</span>( 3 == u8_step )
<a name="l01730"></a>01730       {  <span class="comment">// step 2 = add unit 100 of number</span>
<a name="l01731"></a>01731          character = <span class="charliteral">'0'</span>+(nb/100);
<a name="l01732"></a>01732          u8_step++;                                      <span class="comment">// go to next step</span>
<a name="l01733"></a>01733       }
<a name="l01734"></a>01734       <span class="keywordflow">if</span>( 2 == u8_step )
<a name="l01735"></a>01735       {  <span class="comment">// step 2 = add character '~'</span>
<a name="l01736"></a>01736          character = <span class="charliteral">'~'</span>;
<a name="l01737"></a>01737          u8_step+=(4-nb_digit);                          <span class="comment">// go to next step</span>
<a name="l01738"></a>01738       }
<a name="l01739"></a>01739 
<a name="l01740"></a>01740       <span class="keywordflow">if</span>( mode )
<a name="l01741"></a>01741       {
<a name="l01742"></a>01742          <span class="comment">// Record the short name in buffer</span>
<a name="l01743"></a>01743          *short_name = character;
<a name="l01744"></a>01744          short_name++;
<a name="l01745"></a>01745       }<span class="keywordflow">else</span>{
<a name="l01746"></a>01746          <span class="comment">// Record the character in short entry file</span>
<a name="l01747"></a>01747          *ptr_entry = character;
<a name="l01748"></a>01748          ptr_entry++;
<a name="l01749"></a>01749       }
<a name="l01750"></a>01750       u8_i++;
<a name="l01751"></a>01751 
<a name="l01752"></a>01752       <span class="comment">// Compute the CRC of the short name</span>
<a name="l01753"></a>01753       crc = (crc &gt;&gt; 1) + ((crc &amp; 1) &lt;&lt; 7);               <span class="comment">// rotate</span>
<a name="l01754"></a>01754       crc += character;                                  <span class="comment">// add next char</span>
<a name="l01755"></a>01755    } <span class="comment">// End of loop while</span>
<a name="l01756"></a>01756    <span class="keywordflow">return</span> crc;
<a name="l01757"></a>01757 }
<a name="l01758"></a>01758 
<a name="l01759"></a>01759 
<a name="l01767"></a>01767 U8    <a class="code" href="a00021.html#24d01b29254a31c7b331935fd8288037" title="This function searchs an unique short name.">fat_find_short_entry_name</a>( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_name  )
<a name="l01768"></a><a class="code" href="a00021.html#24d01b29254a31c7b331935fd8288037">01768</a> {
<a name="l01769"></a>01769    <span class="keywordtype">char</span> _MEM_TYPE_SLOW_ short_name[11];
<a name="l01770"></a>01770    U8 u8_nb;
<a name="l01771"></a>01771 
<a name="l01772"></a>01772    u8_nb = 0;
<a name="l01773"></a>01773    <span class="keywordflow">while</span>(1)
<a name="l01774"></a>01774    {
<a name="l01775"></a>01775       <span class="keywordflow">if</span>( 0xFF == u8_nb )
<a name="l01776"></a>01776          <span class="keywordflow">return</span> 0;                                       <span class="comment">// All short name exist</span>
<a name="l01777"></a>01777          
<a name="l01778"></a>01778       u8_nb++;                                           <span class="comment">// Try next short name</span>
<a name="l01779"></a>01779       <a class="code" href="a00021.html#49163f06665633236c432aa1a1163f01" title="This function creates a short name in the internal cache sector OR in a string.">fat_create_short_entry_name</a>( sz_name , short_name , u8_nb , TRUE  ); <span class="comment">// Compute the short name</span>
<a name="l01780"></a>01780       <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a> = 0;          <span class="comment">// Go to beginning of directory</span>
<a name="l01781"></a>01781       <span class="comment">// Scan directory to find a short entry</span>
<a name="l01782"></a>01782       <span class="keywordflow">while</span>(1)
<a name="l01783"></a>01783       {
<a name="l01784"></a>01784          <span class="keywordflow">if</span> ( !<a class="code" href="a00019.html#1a35321a99150ba643f87cb6c79ec3e5" title="This function fill the internal cache with a sector from current directory.">fat_read_dir</a>())                           <span class="comment">// Read directory</span>
<a name="l01785"></a>01785          {
<a name="l01786"></a>01786             <span class="keywordflow">if</span>( <a class="code" href="a00024.html#e8798a89bfc4f49da50fc55b14a5b07f" title="The position is outside the cluster list.">FS_ERR_OUT_LIST</a> == <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> )
<a name="l01787"></a>01787                <span class="keywordflow">return</span> u8_nb;                             <span class="comment">// short name don't exist, then good number</span>
<a name="l01788"></a>01788             <span class="keywordflow">return</span> 0;                                    <span class="comment">// System or Disk Error</span>
<a name="l01789"></a>01789          }
<a name="l01790"></a>01790          <span class="keywordflow">if</span>( <a class="code" href="a00021.html#19c7a66123aba4a4a705623085c03f6f" title="This function compares a short name with the current entry.">fat_entry_shortname_compare</a>( short_name ) ) <span class="comment">// Check entry</span>
<a name="l01791"></a>01791             <span class="keywordflow">break</span>;                                       <span class="comment">// Short name exist</span>
<a name="l01792"></a>01792          <span class="keywordflow">if</span>( <a class="code" href="a00024.html#33817136df196a5f0146574b4e1775b6" title="File entry empty.">FS_ERR_ENTRY_EMPTY</a> == <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> )
<a name="l01793"></a>01793             <span class="keywordflow">return</span> u8_nb;                                <span class="comment">// Short name don't exist, then good number</span>
<a name="l01794"></a>01794          <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>++;         <span class="comment">// Go to next entry</span>
<a name="l01795"></a>01795       }
<a name="l01796"></a>01796    }
<a name="l01797"></a>01797 }
<a name="l01798"></a>01798 
<a name="l01799"></a>01799 
<a name="l01807"></a>01807 Bool  <a class="code" href="a00021.html#19c7a66123aba4a4a705623085c03f6f" title="This function compares a short name with the current entry.">fat_entry_shortname_compare</a>( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> short_name )
<a name="l01808"></a><a class="code" href="a00021.html#19c7a66123aba4a4a705623085c03f6f">01808</a> {
<a name="l01809"></a>01809    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01810"></a>01810 
<a name="l01811"></a>01811    ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l01812"></a>01812    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> == *ptr_entry )             <span class="comment">// end of directory</span>
<a name="l01813"></a>01813    {
<a name="l01814"></a>01814       <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#33817136df196a5f0146574b4e1775b6" title="File entry empty.">FS_ERR_ENTRY_EMPTY</a>;
<a name="l01815"></a>01815       <span class="keywordflow">return</span> FALSE;
<a name="l01816"></a>01816    }
<a name="l01817"></a>01817    <span class="keywordflow">if</span>( (<a class="code" href="a00020.html#303c1237fa5a61ddc015c0365eedd008">FS_ENTRY_DEL</a> == *ptr_entry )            <span class="comment">// deleted entry</span>
<a name="l01818"></a>01818    ||  (<a class="code" href="a00024.html#1aa64d79e89a455b62036d2230fd718d">FS_ATTR_LFN_ENTRY</a> == ptr_entry[11]) )   <span class="comment">// long file name</span>
<a name="l01819"></a>01819    {
<a name="l01820"></a>01820       <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#934f48a8e1cb558d75ec00bbd242030d" title="File entry bad.">FS_ERR_ENTRY_BAD</a>;
<a name="l01821"></a>01821       <span class="keywordflow">return</span> FALSE;
<a name="l01822"></a>01822    }
<a name="l01823"></a>01823    <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#934f48a8e1cb558d75ec00bbd242030d" title="File entry bad.">FS_ERR_ENTRY_BAD</a>;              <span class="comment">// by default this entry is different then bad</span>
<a name="l01824"></a>01824    <span class="keywordflow">return</span> (0==memcmp_ram2ram(ptr_entry , short_name , 8+3 ));
<a name="l01825"></a>01825 }
<a name="l01826"></a>01826 
<a name="l01828"></a>01828 _CONST_TYPE_ U8 <a class="code" href="a00021.html#6584c61d6d4c16ebe9f92c92a53e96bf" title="Characters table no supported in a file name.">fs_s_tab_incorrect_char</a>[]={<span class="charliteral">':'</span>,<span class="charliteral">'*'</span>,<span class="charliteral">'?'</span>,<span class="charliteral">'"'</span>,<span class="charliteral">'&lt;'</span>,<span class="charliteral">'&gt;'</span>,<span class="charliteral">'|'</span>};
<a name="l01829"></a><a class="code" href="a00021.html#6584c61d6d4c16ebe9f92c92a53e96bf">01829</a> 
<a name="l01837"></a>01837 U8    <a class="code" href="a00021.html#8849a8388de3f116fd53fd9ec07747b2" title="This function checks the character in name AND computes the number of entry file...">fat_check_name</a>( <a class="code" href="a00024.html#caff53a7315dfcce82e06ae11c771e8c">FS_STRING</a> sz_name  )
<a name="l01838"></a><a class="code" href="a00021.html#8849a8388de3f116fd53fd9ec07747b2">01838</a> {
<a name="l01839"></a>01839    U8 u8_nb_entry, u8_i, u8_j;
<a name="l01840"></a>01840    U16 u16_character;
<a name="l01841"></a>01841 
<a name="l01842"></a>01842    u8_nb_entry = 2;        <span class="comment">// a short entry + one long name entry minimum</span>
<a name="l01843"></a>01843    u8_i = <a class="code" href="a00020.html#bbdca2b90701f373bf6c865c88c99697">FS_SIZE_LFN_ENTRY</a>;
<a name="l01844"></a>01844    <span class="keywordflow">while</span>( 1 )
<a name="l01845"></a>01845    {
<a name="l01846"></a>01846       <span class="keywordflow">if</span>( <a class="code" href="a00020.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a> )
<a name="l01847"></a>01847       {
<a name="l01848"></a>01848          u16_character = ((<a class="code" href="a00024.html#4b07eeef6c66c629ec6708f8eee35f58">FS_STR_UNICODE</a>)sz_name)[0];
<a name="l01849"></a>01849       }<span class="keywordflow">else</span>{
<a name="l01850"></a>01850          u16_character = sz_name[0];
<a name="l01851"></a>01851       }
<a name="l01852"></a>01852       <span class="keywordflow">if</span>( <a class="code" href="a00019.html#452e159ed5e2a4d8ea88f0515a3a6e10" title="Check end of name.">fat_check_eof_name</a>( u16_character ) )
<a name="l01853"></a>01853          <span class="keywordflow">break</span>;
<a name="l01854"></a>01854 
<a name="l01855"></a>01855       <span class="keywordflow">for</span>( u8_j = 0 ; u8_j &lt; <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#6584c61d6d4c16ebe9f92c92a53e96bf" title="Characters table no supported in a file name.">fs_s_tab_incorrect_char</a>) ; u8_j++ )
<a name="l01856"></a>01856       {
<a name="l01857"></a>01857          <span class="keywordflow">if</span>( u16_character == <a class="code" href="a00021.html#6584c61d6d4c16ebe9f92c92a53e96bf" title="Characters table no supported in a file name.">fs_s_tab_incorrect_char</a>[u8_j] )
<a name="l01858"></a>01858          {
<a name="l01859"></a>01859             <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#6d9fef9edb8adfcebf36e94deab317a2" title="Incorrect name, this one cannot contain any of the following characters \/:*?&amp;quot;&amp;lt;&amp;gt;|...">FS_ERR_INCORRECT_NAME</a>;
<a name="l01860"></a>01860             <span class="keywordflow">return</span> 0;      <span class="comment">// incorrect character</span>
<a name="l01861"></a>01861          }
<a name="l01862"></a>01862       }
<a name="l01863"></a>01863       <span class="keywordflow">if</span>( 0 == u8_i )
<a name="l01864"></a>01864       {
<a name="l01865"></a>01865          u8_nb_entry++;
<a name="l01866"></a>01866          u8_i = <a class="code" href="a00020.html#bbdca2b90701f373bf6c865c88c99697">FS_SIZE_LFN_ENTRY</a>;
<a name="l01867"></a>01867       }
<a name="l01868"></a>01868       u8_i--;
<a name="l01869"></a>01869       sz_name += (<a class="code" href="a00020.html#4ad00946d48b5c25c6734344ecf974c1">Is_unicode</a>? 2 : 1 );
<a name="l01870"></a>01870    }
<a name="l01871"></a>01871    <span class="keywordflow">if</span>( 0x14 &lt; u8_nb_entry )
<a name="l01872"></a>01872    {
<a name="l01873"></a>01873       <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#004446c5c1faf1cfa10df8b72251ddb3" title="The file name is too large (&amp;gt;260 characters).">FS_ERR_NAME_TOO_LARGE</a>;
<a name="l01874"></a>01874       <span class="keywordflow">return</span> 0;            <span class="comment">// Name too large</span>
<a name="l01875"></a>01875    }
<a name="l01876"></a>01876    <span class="keywordflow">return</span> u8_nb_entry;
<a name="l01877"></a>01877 }
<a name="l01878"></a>01878 
<a name="l01879"></a>01879 
<a name="l01881"></a>01881 _CONST_TYPE_ U8 <a class="code" href="a00021.html#89cf8e55b9308a287d4f24c28f8278ed" title="Characters table no supported in a short name.">fs_s_execption_char</a>[]={<span class="charliteral">'+'</span>,<span class="charliteral">','</span>,<span class="charliteral">'.'</span>,<span class="charliteral">';'</span>,<span class="charliteral">'='</span>,<span class="charliteral">'['</span>,<span class="charliteral">']'</span>};
<a name="l01882"></a><a class="code" href="a00021.html#89cf8e55b9308a287d4f24c28f8278ed">01882</a> 
<a name="l01890"></a>01890 U8    <a class="code" href="a00021.html#bb2561113110b35fac032431243f8bb0" title="This function translates the character to autorized short name character.">fat_translate_char_shortname</a>( U8 character )
<a name="l01891"></a><a class="code" href="a00021.html#bb2561113110b35fac032431243f8bb0">01891</a> {
<a name="l01892"></a>01892    U8 u8_j;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894    <span class="keywordflow">if</span>( (character&lt;=<span class="charliteral">' '</span>) || (<span class="charliteral">'~'</span>&lt;character) )
<a name="l01895"></a>01895       <span class="keywordflow">return</span> 0;
<a name="l01896"></a>01896    <span class="keywordflow">if</span>( (<span class="charliteral">'a'</span>&lt;=character) &amp;&amp; (character&lt;=<span class="charliteral">'z'</span>) )
<a name="l01897"></a>01897    {
<a name="l01898"></a>01898       <span class="keywordflow">return</span> (character - (<span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>));  <span class="comment">// Change to upper case</span>
<a name="l01899"></a>01899    }
<a name="l01900"></a>01900    <span class="keywordflow">for</span>( u8_j = 0 ; u8_j &lt; <span class="keyword">sizeof</span>(<a class="code" href="a00021.html#89cf8e55b9308a287d4f24c28f8278ed" title="Characters table no supported in a short name.">fs_s_execption_char</a>) ; u8_j++ )
<a name="l01901"></a>01901    {
<a name="l01902"></a>01902       <span class="keywordflow">if</span>( character == <a class="code" href="a00021.html#89cf8e55b9308a287d4f24c28f8278ed" title="Characters table no supported in a short name.">fs_s_execption_char</a>[u8_j] )
<a name="l01903"></a>01903          <span class="keywordflow">return</span> 0;
<a name="l01904"></a>01904    }
<a name="l01905"></a>01905    <span class="keywordflow">return</span> character;
<a name="l01906"></a>01906 }
<a name="l01907"></a>01907 
<a name="l01908"></a>01908 
<a name="l01920"></a>01920 Bool  <a class="code" href="a00021.html#a2b4dadfd961b4547fd67f7ebe8a5c5d" title="This function allocs a number of entry in a current directory.">fat_alloc_entry_free</a>( U8 u8_nb_entry )
<a name="l01921"></a><a class="code" href="a00021.html#a2b4dadfd961b4547fd67f7ebe8a5c5d">01921</a> {
<a name="l01922"></a>01922    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l01923"></a>01923    Bool b_garbage_collector_used = FALSE;
<a name="l01924"></a>01924    U8 u8_nb_entry_save;
<a name="l01925"></a>01925 
<a name="l01926"></a>01926    u8_nb_entry_save = u8_nb_entry;
<a name="l01927"></a>01927 
<a name="l01928"></a>01928    <span class="comment">// Start at the beginning of dir</span>
<a name="l01929"></a>01929    <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>=0;
<a name="l01930"></a>01930    <span class="comment">// Loop in directory</span>
<a name="l01931"></a>01931    <span class="keywordflow">while</span>( 1 )
<a name="l01932"></a>01932    {
<a name="l01933"></a>01933       <span class="comment">// Fill internal cache with a sector from directory</span>
<a name="l01934"></a>01934       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#1a35321a99150ba643f87cb6c79ec3e5" title="This function fill the internal cache with a sector from current directory.">fat_read_dir</a>() )
<a name="l01935"></a>01935       {
<a name="l01936"></a>01936          <span class="keywordflow">if</span>( <a class="code" href="a00024.html#e8798a89bfc4f49da50fc55b14a5b07f" title="The position is outside the cluster list.">FS_ERR_OUT_LIST</a> != <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> )
<a name="l01937"></a>01937             <span class="keywordflow">return</span> FALSE;
<a name="l01938"></a>01938 
<a name="l01939"></a>01939          <span class="comment">// The position is outside the cluster list</span>
<a name="l01940"></a>01940          <span class="comment">// then alloc a new sector (= new cluster)</span>
<a name="l01941"></a>01941          <span class="comment">// Remark: The fs_g_seg.u32_addr contains the last cluster value of a directory list to link with the new list</span>
<a name="l01942"></a>01942          <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae" title="segment size (unit 512B), or position in cluster list (unit 512B)">u32_size_or_pos</a> = 1;
<a name="l01943"></a>01943          <span class="keywordflow">if</span>( !<a class="code" href="a00020.html#1fa62b2728e71cff2e95556db7ed1b9c" title="This function allocs a cluster list.">fat_allocfreespace</a>())
<a name="l01944"></a>01944          {
<a name="l01945"></a>01945             <span class="comment">// Garbage collector on entry file</span>
<a name="l01946"></a>01946             <span class="keywordflow">if</span>( b_garbage_collector_used )
<a name="l01947"></a>01947                <span class="keywordflow">return</span> FALSE;
<a name="l01948"></a>01948             <span class="keywordflow">if</span>( !<a class="code" href="a00021.html#865edc51b046f0bfc2b1e6d270ed5ac0" title="This function remove the entry delected in the directory to clean it.">fat_garbage_collector_entry</a>())
<a name="l01949"></a>01949                <span class="keywordflow">return</span> FALSE;
<a name="l01950"></a>01950             b_garbage_collector_used = TRUE;
<a name="l01951"></a>01951             <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>=0;
<a name="l01952"></a>01952             u8_nb_entry = u8_nb_entry_save;
<a name="l01953"></a>01953             <span class="keywordflow">continue</span>;
<a name="l01954"></a>01954          }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956          <span class="comment">// Clean this new cluster</span>
<a name="l01957"></a>01957          <span class="comment">// Remark: The fs_g_seg.u32_addr contains the new cluster value</span>
<a name="l01958"></a>01958          <span class="keywordflow">if</span>( !<a class="code" href="a00020.html#6cc9ee9a14553be84990df27709f51a6" title="This function clears one cluster.">fat_clear_cluster</a>())
<a name="l01959"></a>01959             <span class="keywordflow">return</span> FALSE;
<a name="l01960"></a>01960 
<a name="l01961"></a>01961          <span class="keywordflow">continue</span>;  <span class="comment">// Rescan the directory list to find the new allocated sector</span>
<a name="l01962"></a>01962       }
<a name="l01963"></a>01963 
<a name="l01964"></a>01964       <span class="comment">// Check entry</span>
<a name="l01965"></a>01965       ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l01966"></a>01966       <span class="keywordflow">if</span> ( <a class="code" href="a00020.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> == *ptr_entry )
<a name="l01967"></a>01967       {  <span class="comment">// The entry is free</span>
<a name="l01968"></a>01968          u8_nb_entry--;
<a name="l01969"></a>01969          <span class="keywordflow">if</span>( 0 == u8_nb_entry )
<a name="l01970"></a>01970          {
<a name="l01971"></a>01971             <span class="keywordflow">return</span> TRUE;  <span class="comment">// All free entry is found</span>
<a name="l01972"></a>01972          }
<a name="l01973"></a>01973       }
<a name="l01974"></a>01974 
<a name="l01975"></a>01975       <span class="comment">// go to next entry</span>
<a name="l01976"></a>01976       <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>++;
<a name="l01977"></a>01977       <span class="keywordflow">if</span>( 0 == <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a> )
<a name="l01978"></a>01978       {
<a name="l01979"></a>01979          <span class="comment">// Here, the directory have the maximum size</span>
<a name="l01980"></a>01980          <span class="comment">// Garbage collector on entry file</span>
<a name="l01981"></a>01981          <span class="keywordflow">if</span>( b_garbage_collector_used )
<a name="l01982"></a>01982          {
<a name="l01983"></a>01983             <span class="comment">// Directory full (FAT Norm limit directory to 65535 entrys)</span>
<a name="l01984"></a>01984             <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#660c831b30ffc47ef997a2e8ddc66c0d" title="No free cluster found in FAT.">FS_ERR_NO_FREE_SPACE</a>;
<a name="l01985"></a>01985             <span class="keywordflow">return</span> FALSE;
<a name="l01986"></a>01986          }
<a name="l01987"></a>01987          <span class="keywordflow">if</span>( !<a class="code" href="a00021.html#865edc51b046f0bfc2b1e6d270ed5ac0" title="This function remove the entry delected in the directory to clean it.">fat_garbage_collector_entry</a>())
<a name="l01988"></a>01988             <span class="keywordflow">return</span> FALSE;
<a name="l01989"></a>01989          b_garbage_collector_used = TRUE;
<a name="l01990"></a>01990          <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>=0;
<a name="l01991"></a>01991          u8_nb_entry = u8_nb_entry_save;
<a name="l01992"></a>01992          <span class="keywordflow">continue</span>;
<a name="l01993"></a>01993       }
<a name="l01994"></a>01994    }  <span class="comment">// end of while(1)</span>
<a name="l01995"></a>01995 }
<a name="l01996"></a>01996 
<a name="l01997"></a>01997 
<a name="l02003"></a>02003 Bool <a class="code" href="a00021.html#865edc51b046f0bfc2b1e6d270ed5ac0" title="This function remove the entry delected in the directory to clean it.">fat_garbage_collector_entry</a>( <span class="keywordtype">void</span> )
<a name="l02004"></a><a class="code" href="a00021.html#865edc51b046f0bfc2b1e6d270ed5ac0">02004</a> {
<a name="l02005"></a>02005    _MEM_TYPE_SLOW_   U8 entry[ <a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a> ];
<a name="l02006"></a>02006    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l02007"></a>02007    U16 u16_pos_old = 0;
<a name="l02008"></a>02008    U16 u16_pos_new = 0;
<a name="l02009"></a>02009 
<a name="l02010"></a>02010    <span class="comment">// Loop in directory</span>
<a name="l02011"></a>02011    <span class="keywordflow">while</span>( 1 )
<a name="l02012"></a>02012    {
<a name="l02013"></a>02013       <span class="comment">// Go to old entry list</span>
<a name="l02014"></a>02014       <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>=u16_pos_old;
<a name="l02015"></a>02015       <span class="comment">// Fill internal cache with a sector from directory</span>
<a name="l02016"></a>02016       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#1a35321a99150ba643f87cb6c79ec3e5" title="This function fill the internal cache with a sector from current directory.">fat_read_dir</a>() )
<a name="l02017"></a>02017       {
<a name="l02018"></a>02018          <span class="keywordflow">if</span>( <a class="code" href="a00024.html#e8798a89bfc4f49da50fc55b14a5b07f" title="The position is outside the cluster list.">FS_ERR_OUT_LIST</a> != <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> )
<a name="l02019"></a>02019             <span class="keywordflow">return</span> FALSE;
<a name="l02020"></a>02020          <span class="keywordflow">goto</span> fat_garbage_collector_entry_endofdir;
<a name="l02021"></a>02021       }
<a name="l02022"></a>02022 
<a name="l02023"></a>02023       <span class="comment">// Check entry</span>
<a name="l02024"></a>02024       ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l02025"></a>02025 
<a name="l02026"></a>02026       <span class="keywordflow">if</span> ( <a class="code" href="a00020.html#453bf57f059970b3ce13033b7959cb0c">FS_ENTRY_END</a> == *ptr_entry )
<a name="l02027"></a>02027       {
<a name="l02028"></a>02028          <span class="comment">// The entry is free, then it is the end of entry list</span>
<a name="l02029"></a>02029 fat_garbage_collector_entry_endofdir:
<a name="l02030"></a>02030          <span class="comment">// Fill empty entry in old list</span>
<a name="l02031"></a>02031          <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>=u16_pos_new;
<a name="l02032"></a>02032          <span class="keywordflow">while</span>( <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a> != u16_pos_old )
<a name="l02033"></a>02033          {
<a name="l02034"></a>02034             <span class="comment">// Fill internal cache with a sector from directory</span>
<a name="l02035"></a>02035             <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#1a35321a99150ba643f87cb6c79ec3e5" title="This function fill the internal cache with a sector from current directory.">fat_read_dir</a>() )
<a name="l02036"></a>02036                <span class="keywordflow">return</span> FALSE;
<a name="l02037"></a>02037             memset( <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>() , 0 , 32 );
<a name="l02038"></a>02038             <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l02039"></a>02039             <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>++;
<a name="l02040"></a>02040          }
<a name="l02041"></a>02041          <span class="keywordflow">return</span> TRUE;  <span class="comment">// End of garbage</span>
<a name="l02042"></a>02042       }
<a name="l02043"></a>02043 
<a name="l02044"></a>02044       <span class="keywordflow">if</span> ( <a class="code" href="a00020.html#303c1237fa5a61ddc015c0365eedd008">FS_ENTRY_DEL</a> != *ptr_entry )
<a name="l02045"></a>02045       {
<a name="l02046"></a>02046          <span class="comment">// entry valid</span>
<a name="l02047"></a>02047          <span class="keywordflow">if</span>( u16_pos_old != u16_pos_new )
<a name="l02048"></a>02048          {
<a name="l02049"></a>02049             <span class="comment">// A free space exist then move entry</span>
<a name="l02050"></a>02050             memcpy_ram2ram( entry, ptr_entry, <a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a> );
<a name="l02051"></a>02051             <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>=u16_pos_new;
<a name="l02052"></a>02052             <span class="comment">// Fill internal cache with a sector from directory</span>
<a name="l02053"></a>02053             <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#1a35321a99150ba643f87cb6c79ec3e5" title="This function fill the internal cache with a sector from current directory.">fat_read_dir</a>() )
<a name="l02054"></a>02054                <span class="keywordflow">return</span> FALSE;
<a name="l02055"></a>02055             memcpy_ram2ram( <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>(), entry, <a class="code" href="a00020.html#0ff67916e073882d162d5fbac91d7e50">FS_SIZE_FILE_ENTRY</a> );
<a name="l02056"></a>02056             <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l02057"></a>02057          }
<a name="l02058"></a>02058          u16_pos_new++;
<a name="l02059"></a>02059       }
<a name="l02060"></a>02060       u16_pos_old++;
<a name="l02061"></a>02061    }  <span class="comment">// end of while(1)</span>
<a name="l02062"></a>02062 }
<a name="l02063"></a>02063 
<a name="l02064"></a>02064 
<a name="l02073"></a>02073 Bool  <a class="code" href="a00020.html#797fc629a4a513e6a5f2951720da5d47" title="This function deletes the file entries and cluster list.">fat_delete_file</a>( Bool b_cluster_list )
<a name="l02074"></a><a class="code" href="a00021.html#797fc629a4a513e6a5f2951720da5d47">02074</a> {
<a name="l02075"></a>02075    <a class="code" href="a00020.html#119f57abfa3b1f77fd0514b26da6afb4">PTR_CACHE</a> ptr_entry;
<a name="l02076"></a>02076    U8 u8_tmp;
<a name="l02077"></a>02077    Bool b_short_del = FALSE;
<a name="l02078"></a>02078 
<a name="l02079"></a>02079    <span class="comment">// loop in directory</span>
<a name="l02080"></a>02080    <span class="keywordflow">while</span>( 1 )
<a name="l02081"></a>02081    {
<a name="l02082"></a>02082       <span class="comment">// Fill internal cache with a sector from directory</span>
<a name="l02083"></a>02083       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#1a35321a99150ba643f87cb6c79ec3e5" title="This function fill the internal cache with a sector from current directory.">fat_read_dir</a>() )
<a name="l02084"></a>02084          <span class="keywordflow">return</span> FALSE;
<a name="l02085"></a>02085 
<a name="l02086"></a>02086       <span class="comment">// Get pointer on the current entry</span>
<a name="l02087"></a>02087       ptr_entry = <a class="code" href="a00019.html#0c24a717d004b7194e2c566522348fd5" title="This function returns a cache pointer on the current entry.">fat_get_ptr_entry</a>();
<a name="l02088"></a>02088       u8_tmp = ptr_entry[0];
<a name="l02089"></a>02089 
<a name="l02090"></a>02090       <span class="keywordflow">if</span>( (<a class="code" href="a00024.html#1aa64d79e89a455b62036d2230fd718d">FS_ATTR_LFN_ENTRY</a> != ptr_entry[11])
<a name="l02091"></a>02091       &amp;&amp;  (b_short_del) )
<a name="l02092"></a>02092       {
<a name="l02093"></a>02093          <span class="comment">// no long entry exist, then only a short entry to delete</span>
<a name="l02094"></a>02094          <span class="keywordflow">break</span>;   <span class="comment">// Go to delete cluster list</span>
<a name="l02095"></a>02095       }
<a name="l02096"></a>02096 
<a name="l02097"></a>02097       <span class="comment">// Delete entry</span>
<a name="l02098"></a>02098       b_short_del = TRUE;
<a name="l02099"></a>02099       ptr_entry[0] = <a class="code" href="a00020.html#303c1237fa5a61ddc015c0365eedd008">FS_ENTRY_DEL</a>;
<a name="l02100"></a>02100       <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l02101"></a>02101 
<a name="l02102"></a>02102       <span class="keywordflow">if</span>( (<a class="code" href="a00024.html#1aa64d79e89a455b62036d2230fd718d">FS_ATTR_LFN_ENTRY</a> == ptr_entry[11])
<a name="l02103"></a>02103       &amp;&amp;  ( 0 != (<a class="code" href="a00020.html#bf0fa999d28907c3742656b6407aca78">FS_ENTRY_LFN_LAST</a> &amp; u8_tmp)) )
<a name="l02104"></a>02104       {
<a name="l02105"></a>02105          <span class="comment">// It is the last entry of long name</span>
<a name="l02106"></a>02106          <span class="keywordflow">break</span>;   <span class="comment">// Go to delete cluster list</span>
<a name="l02107"></a>02107       }
<a name="l02108"></a>02108 
<a name="l02109"></a>02109       <span class="comment">// Go to previous entry</span>
<a name="l02110"></a>02110       <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#9f50297ed427918e54da99b8c4fbaf04" title="Entry file position in directory (unit = FS_SIZE_FILE_ENTRY) (see value FS_NO_SEL...">u16_entry_pos_sel_file</a>--;
<a name="l02111"></a>02111    }  <span class="comment">// end of while(1)</span>
<a name="l02112"></a>02112 
<a name="l02113"></a>02113    <span class="keywordflow">if</span>( b_cluster_list )
<a name="l02114"></a>02114    {
<a name="l02115"></a>02115       <span class="comment">// Delete cluster list</span>
<a name="l02116"></a>02116       <a class="code" href="a00020.html#fcc9a3eb6084fd54807483346dfc5d09">fs_g_nav_entry</a>.<a class="code" href="a00005.html#1e1dae249ae6839c1b8cce0fecbbf7af" title="Current position in file (unit Bytes).">u32_pos_in_file</a>=0;      <span class="comment">// Delete ALL list (start at begining)</span>
<a name="l02117"></a>02117       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#d8c9c9a63c821e8cea06c340c029668d" title="This function gets or clears a cluster list at the current position in the selected...">fat_read_file</a>( <a class="code" href="a00020.html#b314d14ba33772e9bcbae993a8d17e9f">FS_CLUST_ACT_CLR</a> ))
<a name="l02118"></a>02118          <span class="keywordflow">return</span> FALSE;
<a name="l02119"></a>02119    }
<a name="l02120"></a>02120 
<a name="l02121"></a>02121    <span class="keywordflow">return</span> TRUE;
<a name="l02122"></a>02122 }
<a name="l02123"></a>02123 <span class="preprocessor">#endif  // FS_LEVEL_FEATURES</span>
<a name="l02124"></a>02124 <span class="preprocessor"></span>
<a name="l02125"></a>02125 
<a name="l02126"></a>02126 
<a name="l02132"></a>02132 U32   <a class="code" href="a00020.html#e23270781477be5e6c89b90531c01651" title="This function returns the space free in the partition.">fat_getfreespace</a>( <span class="keywordtype">void</span> )
<a name="l02133"></a><a class="code" href="a00021.html#e23270781477be5e6c89b90531c01651">02133</a> {
<a name="l02134"></a>02134    U32 u32_nb_free_cluster = 0;
<a name="l02135"></a>02135 
<a name="l02136"></a>02136    <span class="comment">// Read ALL FAT1</span>
<a name="l02137"></a>02137    <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> = 2;
<a name="l02138"></a>02138 
<a name="l02139"></a>02139    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l02140"></a>02140    {  <span class="comment">// FAT12 only</span>
<a name="l02141"></a>02141       <span class="keywordflow">for</span>(
<a name="l02142"></a>02142       ;     <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> &lt; <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a>
<a name="l02143"></a>02143       ;     <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a>++ )
<a name="l02144"></a>02144       {
<a name="l02145"></a>02145          <span class="comment">// Get the value of the cluster</span>
<a name="l02146"></a>02146          <span class="keywordflow">if</span> ( !<a class="code" href="a00019.html#1be84552293d174f534b2fb8d0a4e737" title="This function returns or modifys a cluster value in FAT.">fat_cluster_val</a>( <a class="code" href="a00020.html#087734ece5cae84508fd1fbe9414ad02">FS_CLUST_VAL_READ</a> ) )
<a name="l02147"></a>02147             <span class="keywordflow">return</span> 0;
<a name="l02148"></a>02148 
<a name="l02149"></a>02149          <span class="keywordflow">if</span> ( 0 == <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#4f323a1ec38e3c0f1b57bf4fe07842b7" title="cluster value">u32_val</a> )
<a name="l02150"></a>02150             u32_nb_free_cluster++;
<a name="l02151"></a>02151       }
<a name="l02152"></a>02152    }
<a name="l02153"></a>02153    <span class="keywordflow">else</span>
<a name="l02154"></a>02154    {
<a name="l02155"></a>02155       <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l02156"></a>02156       {
<a name="l02157"></a>02157          u32_nb_free_cluster = <a class="code" href="a00020.html#0a8beb16a074b07828fc725e0c0ae500" title="This function returns the space free in the selected FAT32 partition.">fat_read_fat32_FSInfo</a>();
<a name="l02158"></a>02158          <span class="keywordflow">if</span>( 0xFFFFFFFF != u32_nb_free_cluster )
<a name="l02159"></a>02159             <span class="keywordflow">goto</span> endof_fat_getfreespace;
<a name="l02160"></a>02160          u32_nb_free_cluster = 0;
<a name="l02161"></a>02161       }
<a name="l02162"></a>02162       <span class="comment">// Speed optimization only for FAT16 and FAT32</span>
<a name="l02163"></a>02163       <span class="comment">// init first value used by fat_cluster_readnext()</span>
<a name="l02164"></a>02164       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#1be84552293d174f534b2fb8d0a4e737" title="This function returns or modifys a cluster value in FAT.">fat_cluster_val</a>( <a class="code" href="a00020.html#087734ece5cae84508fd1fbe9414ad02">FS_CLUST_VAL_READ</a> ))
<a name="l02165"></a>02165          <span class="keywordflow">return</span> FALSE;
<a name="l02166"></a>02166       <span class="keywordflow">for</span>(
<a name="l02167"></a>02167       ;     <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> &lt; <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a>
<a name="l02168"></a>02168       ;     <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a>++ )
<a name="l02169"></a>02169       {
<a name="l02170"></a>02170          <span class="keywordflow">if</span> ( 0 == <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#4f323a1ec38e3c0f1b57bf4fe07842b7" title="cluster value">u32_val</a> )
<a name="l02171"></a>02171             u32_nb_free_cluster++;
<a name="l02172"></a>02172          <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#e28958d1a5e3ed006edf937e6b7dacc7" title="This function is optimized to read a continue cluster list on FAT16 and FAT32.">fat_cluster_readnext</a>() )
<a name="l02173"></a>02173             <span class="keywordflow">return</span> FALSE;
<a name="l02174"></a>02174       }
<a name="l02175"></a>02175 <span class="preprocessor">#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES &amp; FSFEATURE_WRITE_COMPLET) )</span>
<a name="l02176"></a>02176 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l02177"></a>02177       {
<a name="l02178"></a>02178          <span class="comment">// Save value for the future call</span>
<a name="l02179"></a>02179          <a class="code" href="a00020.html#9cf154ffe36bc2c00b1d589e523b449c" title="This function writes the space free number in selected FAT32 partition.">fat_write_fat32_FSInfo</a>( u32_nb_free_cluster );
<a name="l02180"></a>02180       }
<a name="l02181"></a>02181 <span class="preprocessor">#endif</span>
<a name="l02182"></a>02182 <span class="preprocessor"></span>   }
<a name="l02183"></a>02183 endof_fat_getfreespace:
<a name="l02184"></a>02184    <span class="keywordflow">return</span> (u32_nb_free_cluster * <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>);
<a name="l02185"></a>02185 }
<a name="l02186"></a>02186 
<a name="l02187"></a>02187 
<a name="l02197"></a>02197 U8    <a class="code" href="a00020.html#14426d5552b72b88ea0d61828c57d6c6" title="This function returns the space free in percent.">fat_getfreespace_percent</a>( <span class="keywordtype">void</span> )
<a name="l02198"></a><a class="code" href="a00021.html#14426d5552b72b88ea0d61828c57d6c6">02198</a> {
<a name="l02199"></a>02199    U32 u32_nb_free_cluster = 0;
<a name="l02200"></a>02200    U16 u16_tmp, u16_pos;
<a name="l02201"></a>02201 
<a name="l02202"></a>02202    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#c2ce5473766316396fb472c1bdd685e9">Is_fat12</a> )
<a name="l02203"></a>02203    {  <span class="comment">// No speed optimization necessary on FAT12</span>
<a name="l02204"></a>02204       <span class="keywordflow">return</span> (((<a class="code" href="a00020.html#e23270781477be5e6c89b90531c01651" title="This function returns the space free in the partition.">fat_getfreespace</a>()/<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>)*100) / <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a>);
<a name="l02205"></a>02205    }
<a name="l02206"></a>02206 
<a name="l02207"></a>02207 
<a name="l02208"></a>02208    <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> = 2;
<a name="l02209"></a>02209    <span class="comment">// Init first value used by fat_cluster_readnext()</span>
<a name="l02210"></a>02210    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#1be84552293d174f534b2fb8d0a4e737" title="This function returns or modifys a cluster value in FAT.">fat_cluster_val</a>( <a class="code" href="a00020.html#087734ece5cae84508fd1fbe9414ad02">FS_CLUST_VAL_READ</a> ))
<a name="l02211"></a>02211       <span class="keywordflow">return</span> FALSE;
<a name="l02212"></a>02212 
<a name="l02213"></a>02213    <span class="comment">// The optimization is to</span>
<a name="l02214"></a>02214    <span class="comment">// - read only the LSB byte of cluster</span>
<a name="l02215"></a>02215    <span class="comment">// - read only 1 cluster for 2 clusters</span>
<a name="l02216"></a>02216    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l02217"></a>02217    {
<a name="l02218"></a>02218       u32_nb_free_cluster = <a class="code" href="a00020.html#0a8beb16a074b07828fc725e0c0ae500" title="This function returns the space free in the selected FAT32 partition.">fat_read_fat32_FSInfo</a>();
<a name="l02219"></a>02219       <span class="keywordflow">if</span>( 0xFFFFFFFF != u32_nb_free_cluster )
<a name="l02220"></a>02220          <span class="keywordflow">goto</span> endof_fat_getfreespace_percent;
<a name="l02221"></a>02221       u32_nb_free_cluster = 0;
<a name="l02222"></a>02222 
<a name="l02223"></a>02223       u16_pos = 2*4;
<a name="l02224"></a>02224       <span class="keywordflow">for</span>(  u16_tmp = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>
<a name="l02225"></a>02225       ;     u16_tmp!=0
<a name="l02226"></a>02226       ;     u16_tmp-- )
<a name="l02227"></a>02227       {
<a name="l02228"></a>02228          <span class="keywordflow">for</span>( ; u16_pos &lt; 512 ; u16_pos += (2*4) )
<a name="l02229"></a>02229          {
<a name="l02230"></a>02230             <span class="keywordflow">if</span>( 0 == <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[u16_pos] )
<a name="l02231"></a>02231                u32_nb_free_cluster+=2;
<a name="l02232"></a>02232          }
<a name="l02233"></a>02233          <span class="comment">// Read next sector in FAT</span>
<a name="l02234"></a>02234          u16_pos = 0;
<a name="l02235"></a>02235          <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>++;
<a name="l02236"></a>02236          <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( TRUE ))
<a name="l02237"></a>02237             <span class="keywordflow">return</span> 0;
<a name="l02238"></a>02238       }
<a name="l02239"></a>02239    }
<a name="l02240"></a>02240 
<a name="l02241"></a>02241    <span class="keywordflow">if</span> ( <a class="code" href="a00020.html#2dcd74d640da1e20ad510413c9ef4c85">Is_fat16</a> )
<a name="l02242"></a>02242    {
<a name="l02243"></a>02243       u16_pos = 2*2;
<a name="l02244"></a>02244 
<a name="l02245"></a>02245       <span class="keywordflow">for</span>(  u16_tmp = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>
<a name="l02246"></a>02246       ;     u16_tmp!=0
<a name="l02247"></a>02247       ;     u16_tmp-- )
<a name="l02248"></a>02248       {
<a name="l02249"></a>02249          <span class="keywordflow">for</span>( ; u16_pos &lt; 512 ; u16_pos += (2*2) )
<a name="l02250"></a>02250          {
<a name="l02251"></a>02251             <span class="keywordflow">if</span>( 0 == <a class="code" href="a00020.html#a84f1da7d8ef3aa46b236f6a7a3b0fa1" title="Use &amp;quot;FAT sector cache&amp;quot; to store a sector from a file (see file_putc(),...">fs_g_sector</a>[u16_pos] )
<a name="l02252"></a>02252                u32_nb_free_cluster+=2;
<a name="l02253"></a>02253          }
<a name="l02254"></a>02254          <span class="comment">// Read next sector in FAT</span>
<a name="l02255"></a>02255          u16_pos = 0;
<a name="l02256"></a>02256          <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>++;
<a name="l02257"></a>02257          <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( TRUE ))
<a name="l02258"></a>02258             <span class="keywordflow">return</span> 0;
<a name="l02259"></a>02259       }
<a name="l02260"></a>02260    }
<a name="l02261"></a>02261 
<a name="l02262"></a>02262    <span class="comment">// Compute percent</span>
<a name="l02263"></a>02263    <span class="keywordflow">if</span>( u32_nb_free_cluster &gt; <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a> )
<a name="l02264"></a>02264       <span class="keywordflow">return</span> 100;
<a name="l02265"></a>02265    <span class="keywordflow">if</span>( u32_nb_free_cluster &gt; ((<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a>-u32_nb_free_cluster)/256) )
<a name="l02266"></a>02266    {
<a name="l02267"></a>02267       <span class="comment">// Compute and add a delta error</span>
<a name="l02268"></a>02268       u32_nb_free_cluster -= ((<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a>-u32_nb_free_cluster)/256);
<a name="l02269"></a>02269    }
<a name="l02270"></a>02270 endof_fat_getfreespace_percent:
<a name="l02271"></a>02271    <span class="keywordflow">return</span> ((u32_nb_free_cluster * 100) / <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a>);
<a name="l02272"></a>02272 }
<a name="l02273"></a>02273 
<a name="l02274"></a>02274 
<a name="l02275"></a>02275 
<a name="l02276"></a>02276 <span class="preprocessor">#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES &amp; FSFEATURE_WRITE))</span>
<a name="l02293"></a>02293 <span class="preprocessor">Bool  fat_allocfreespace( void )</span>
<a name="l02294"></a><a class="code" href="a00021.html#1fa62b2728e71cff2e95556db7ed1b9c">02294</a> <span class="preprocessor"></span>{
<a name="l02295"></a>02295    <span class="comment">// Flag to signal the first step which search the first free cluster of the new list</span>
<a name="l02296"></a>02296    Bool first_cluster_free_is_found = FALSE;
<a name="l02297"></a>02297    <span class="comment">// If TRUE then use a quick procedure but don't scan all FAT else use a slow proceudre but scan all FAT</span>
<a name="l02298"></a>02298    Bool b_quick_find = TRUE;
<a name="l02299"></a>02299 
<a name="l02300"></a>02300    <span class="keywordflow">if</span>( <a class="code" href="a00020.html#57a82f24a45a33a159e0362b7e82e3fa">Is_fat32</a> )
<a name="l02301"></a>02301    {
<a name="l02302"></a>02302       <span class="comment">// Clear info about free space</span>
<a name="l02303"></a>02303       <span class="keywordflow">if</span>( !<a class="code" href="a00020.html#9cf154ffe36bc2c00b1d589e523b449c" title="This function writes the space free number in selected FAT32 partition.">fat_write_fat32_FSInfo</a>( 0xFFFFFFFF ))
<a name="l02304"></a>02304          <span class="keywordflow">return</span> FALSE;
<a name="l02305"></a>02305    }
<a name="l02306"></a>02306 
<a name="l02307"></a>02307    <span class="keywordflow">if</span>( 0xFF == MSB0(<a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172" title="segment address (unit 512B), or cluster number">u32_addr</a>) )
<a name="l02308"></a>02308    {
<a name="l02309"></a>02309 fat_allocfreespace_start:
<a name="l02310"></a>02310       <span class="comment">// New cluster list, then research at the beginning of FAT</span>
<a name="l02311"></a>02311       <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> = 2;
<a name="l02312"></a>02312    }<span class="keywordflow">else</span>{
<a name="l02313"></a>02313       <span class="comment">// Continue the cluster list then start after the end of the cluster list</span>
<a name="l02314"></a>02314       <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> = <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172" title="segment address (unit 512B), or cluster number">u32_addr</a>+1;
<a name="l02315"></a>02315    }
<a name="l02316"></a>02316 
<a name="l02317"></a>02317    <a class="code" href="a00020.html#9503329592cf7484faf77ca95a6a21aa" title="This function clears the cache information about FAT modifications.">fat_clear_info_fat_mod</a>();
<a name="l02318"></a>02318 
<a name="l02319"></a>02319    <span class="comment">// Read ALL FAT1</span>
<a name="l02320"></a>02320    <span class="keywordflow">for</span>(
<a name="l02321"></a>02321    ;     <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> &lt; <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#2f9e0c9af661ea927729c08280e1105e" title="Number of cluster (include the two reserved cluster).">u32_CountofCluster</a>
<a name="l02322"></a>02322    ;     <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a>++ )
<a name="l02323"></a>02323    {
<a name="l02324"></a>02324       <span class="comment">// Get the value of the cluster</span>
<a name="l02325"></a>02325       <span class="keywordflow">if</span> ( !<a class="code" href="a00019.html#1be84552293d174f534b2fb8d0a4e737" title="This function returns or modifys a cluster value in FAT.">fat_cluster_val</a>( <a class="code" href="a00020.html#087734ece5cae84508fd1fbe9414ad02">FS_CLUST_VAL_READ</a> ) )
<a name="l02326"></a>02326          <span class="keywordflow">return</span> FALSE;
<a name="l02327"></a>02327 
<a name="l02328"></a>02328       <span class="keywordflow">if</span> ( 0 == <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#4f323a1ec38e3c0f1b57bf4fe07842b7" title="cluster value">u32_val</a> )
<a name="l02329"></a>02329       {
<a name="l02330"></a>02330          <span class="comment">// A free cluster is found</span>
<a name="l02331"></a>02331          <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#4f323a1ec38e3c0f1b57bf4fe07842b7" title="cluster value">u32_val</a> = <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a>;    <span class="comment">// value of the cluster is the new free cluster</span>
<a name="l02332"></a>02332          <span class="keywordflow">if</span>( TRUE == first_cluster_free_is_found )
<a name="l02333"></a>02333          {
<a name="l02334"></a>02334             <span class="comment">// Link the new cluster with previous cluster</span>
<a name="l02335"></a>02335             <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a>--;                      <span class="comment">// select the previous cluster</span>
<a name="l02336"></a>02336             <span class="keywordflow">if</span> ( !<a class="code" href="a00019.html#1be84552293d174f534b2fb8d0a4e737" title="This function returns or modifys a cluster value in FAT.">fat_cluster_val</a>( <a class="code" href="a00020.html#c11d0331723bc237aac4d6c7a4fe7496">FS_CLUST_VAL_WRITE</a> ) )
<a name="l02337"></a>02337                <span class="keywordflow">return</span> FALSE;
<a name="l02338"></a>02338          }
<a name="l02339"></a>02339          <span class="keywordflow">else</span>
<a name="l02340"></a>02340          {
<a name="l02341"></a>02341             <span class="comment">// It is the first cluster of the new list</span>
<a name="l02342"></a>02342             first_cluster_free_is_found = TRUE;
<a name="l02343"></a>02343 
<a name="l02344"></a>02344             <span class="keywordflow">if</span>( 0xFF != MSB0(<a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172" title="segment address (unit 512B), or cluster number">u32_addr</a>) )
<a name="l02345"></a>02345             {
<a name="l02346"></a>02346                <span class="comment">// Link this new cluster with the current cluster list</span>
<a name="l02347"></a>02347                <span class="comment">// Select the last cluster of the current list</span>
<a name="l02348"></a>02348                <span class="keywordflow">if</span>( 0 == <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172" title="segment address (unit 512B), or cluster number">u32_addr</a> )
<a name="l02349"></a>02349                {  <span class="comment">// The current cluster list is the cluster list of root directory</span>
<a name="l02350"></a>02350                   <span class="keywordflow">if</span>( <a class="code" href="a00020.html#bed7b1e094b19dac8efa753f59f84fc6">FS_TYPE_FAT_32</a> != <a class="code" href="a00020.html#14ab00294275fb02f822b22d7dcc6b13">fs_g_nav_fast</a>.<a class="code" href="a00006.html#74121fb3c8d3a1d018c911650e2ec920" title="FAT type (default = no mounted = FS_TYPE_FAT_UNM).">u8_type_fat</a> )
<a name="l02351"></a>02351                   {
<a name="l02352"></a>02352                      <span class="comment">// Impossible to increment ROOT DIR size of FAT12 or FAT16</span>
<a name="l02353"></a>02353                      <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#660c831b30ffc47ef997a2e8ddc66c0d" title="No free cluster found in FAT.">FS_ERR_NO_FREE_SPACE</a>;
<a name="l02354"></a>02354                      <span class="keywordflow">return</span> FALSE;
<a name="l02355"></a>02355                   }
<a name="l02356"></a>02356                   <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#b26050633d0597af6c2c6abe9684481b" title="Root directory informations.">rootdir</a>.<a class="code" href="a00007.html#54d1e701d0705a2b2adb2b2cdc2e604b" title="For FAT32, the root directory is a cluster list.">u32_cluster</a>;
<a name="l02357"></a>02357                }
<a name="l02358"></a>02358                <span class="keywordflow">else</span>
<a name="l02359"></a>02359                {
<a name="l02360"></a>02360                   <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> = <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172" title="segment address (unit 512B), or cluster number">u32_addr</a>;
<a name="l02361"></a>02361                }
<a name="l02362"></a>02362                <span class="keywordflow">if</span> ( !<a class="code" href="a00019.html#1be84552293d174f534b2fb8d0a4e737" title="This function returns or modifys a cluster value in FAT.">fat_cluster_val</a>( <a class="code" href="a00020.html#c11d0331723bc237aac4d6c7a4fe7496">FS_CLUST_VAL_WRITE</a> ) )
<a name="l02363"></a>02363                   <span class="keywordflow">return</span> FALSE;
<a name="l02364"></a>02364             }  <span class="comment">// else no writing the first cluster value in FAT because no current cluster list</span>
<a name="l02365"></a>02365             <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172" title="segment address (unit 512B), or cluster number">u32_addr</a> = <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#4f323a1ec38e3c0f1b57bf4fe07842b7" title="cluster value">u32_val</a>;    <span class="comment">// save the first cluster value</span>
<a name="l02366"></a>02366          }
<a name="l02367"></a>02367 
<a name="l02368"></a>02368          <span class="comment">// At the new cluster position, set the flag end of list</span>
<a name="l02369"></a>02369          <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> = <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#4f323a1ec38e3c0f1b57bf4fe07842b7" title="cluster value">u32_val</a>;    <span class="comment">// Select the new cluster</span>
<a name="l02370"></a>02370          <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#4f323a1ec38e3c0f1b57bf4fe07842b7" title="cluster value">u32_val</a> = <a class="code" href="a00020.html#6a0f491ab351899993a4171f5ff526f3">FS_CLUST_VAL_EOL</a>;        <span class="comment">// Cluster value is the flag end of list</span>
<a name="l02371"></a>02371          <span class="keywordflow">if</span> ( !<a class="code" href="a00019.html#1be84552293d174f534b2fb8d0a4e737" title="This function returns or modifys a cluster value in FAT.">fat_cluster_val</a>( <a class="code" href="a00020.html#c11d0331723bc237aac4d6c7a4fe7496">FS_CLUST_VAL_WRITE</a> ) )
<a name="l02372"></a>02372             <span class="keywordflow">return</span> FALSE;
<a name="l02373"></a>02373 
<a name="l02374"></a>02374          <span class="comment">// Compute the remaining sectors</span>
<a name="l02375"></a>02375          <span class="keywordflow">if</span> ( <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae" title="segment size (unit 512B), or position in cluster list (unit 512B)">u32_size_or_pos</a> &lt;= <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a> )
<a name="l02376"></a>02376          {
<a name="l02377"></a>02377             <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae" title="segment size (unit 512B), or position in cluster list (unit 512B)">u32_size_or_pos</a> = 0; <span class="comment">// All space found</span>
<a name="l02378"></a>02378             <span class="keywordflow">break</span>;                        <span class="comment">// Stop loop</span>
<a name="l02379"></a>02379          }
<a name="l02380"></a>02380          <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae" title="segment size (unit 512B), or position in cluster list (unit 512B)">u32_size_or_pos</a> -= <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a>;
<a name="l02381"></a>02381       }
<a name="l02382"></a>02382       <span class="keywordflow">else</span>
<a name="l02383"></a>02383       {
<a name="l02384"></a>02384          <span class="comment">// The next cluster is not free</span>
<a name="l02385"></a>02385          <span class="keywordflow">if</span>( TRUE == first_cluster_free_is_found )
<a name="l02386"></a>02386          {
<a name="l02387"></a>02387             <span class="comment">// To have a segment memory continue, the cluster list must be continue</span>
<a name="l02388"></a>02388             <span class="comment">// then stop allocation</span>
<a name="l02389"></a>02389             <span class="keywordflow">break</span>;
<a name="l02390"></a>02390          }
<a name="l02391"></a>02391          <span class="keywordflow">else</span>
<a name="l02392"></a>02392          {
<a name="l02393"></a>02393             <span class="comment">// It is the first step to search the first free cluster</span>
<a name="l02394"></a>02394             <span class="comment">// then ignore this cluster no free and continue search</span>
<a name="l02395"></a>02395             <span class="keywordflow">if</span>( b_quick_find )
<a name="l02396"></a>02396             {
<a name="l02397"></a>02397                <a class="code" href="a00020.html#f1ca07cf6181c8e6af3fa988a0b0539d" title="To take time in functions: fat_getfreespace, fat_cluster_list, fat_cluster_val, fat_checkcluster...">fs_g_cluster</a>.<a class="code" href="a00012.html#06879786792eeefd3b45527499ed1174" title="cluster position">u32_pos</a> += 500;
<a name="l02398"></a>02398             }
<a name="l02399"></a>02399          }
<a name="l02400"></a>02400       }
<a name="l02401"></a>02401    }
<a name="l02402"></a>02402 
<a name="l02403"></a>02403    <span class="comment">// End of alloc</span>
<a name="l02404"></a>02404    <span class="keywordflow">if</span>( FALSE == first_cluster_free_is_found )
<a name="l02405"></a>02405    {
<a name="l02406"></a>02406       <span class="keywordflow">if</span>( b_quick_find )
<a name="l02407"></a>02407       {
<a name="l02408"></a>02408          <span class="comment">// Retry in normal mode to scann all FAT (= no quick mode)</span>
<a name="l02409"></a>02409          b_quick_find = FALSE;
<a name="l02410"></a>02410          <span class="keywordflow">goto</span> fat_allocfreespace_start;
<a name="l02411"></a>02411       }
<a name="l02412"></a>02412       <a class="code" href="a00024.html#3eebd84ddd08a3d4163af24e2722de3c">fs_g_status</a> = <a class="code" href="a00024.html#660c831b30ffc47ef997a2e8ddc66c0d" title="No free cluster found in FAT.">FS_ERR_NO_FREE_SPACE</a>; <span class="comment">// NO FREE CLUSTER FIND</span>
<a name="l02413"></a>02413       <span class="keywordflow">return</span> FALSE;
<a name="l02414"></a>02414    }
<a name="l02415"></a>02415 
<a name="l02416"></a>02416    <span class="keywordflow">return</span> <a class="code" href="a00020.html#8145cff91620fc1b70aa0eef5750db72" title="This function copys the modifications of the first FAT to the second FAT.">fat_update_fat2</a>();
<a name="l02417"></a>02417 }
<a name="l02418"></a>02418 <span class="preprocessor">#endif  // FS_LEVEL_FEATURES</span>
<a name="l02419"></a>02419 <span class="preprocessor"></span>
<a name="l02420"></a>02420 
<a name="l02421"></a>02421 <span class="preprocessor">#if (FS_LEVEL_FEATURES &gt; FSFEATURE_READ)</span>
<a name="l02424"></a>02424 <span class="preprocessor">void  fat_clear_info_fat_mod( void )</span>
<a name="l02425"></a><a class="code" href="a00021.html#9503329592cf7484faf77ca95a6a21aa">02425</a> <span class="preprocessor"></span>{
<a name="l02426"></a>02426    <a class="code" href="a00020.html#b55b94c50b63cf8b83e2afcf2e0c2981" title="Offset (unit 512B) in fat of the first sector (unit 512B).">fs_g_u16_first_mod_fat</a> = 0xFFFF;
<a name="l02427"></a>02427    <a class="code" href="a00020.html#e8c6fce6d75eb9ddbf1e63e46659e9cc" title="Offset (unit 512B) in fat of the last sector (unit 512B).">fs_g_u16_last_mod_fat</a> = 0;
<a name="l02428"></a>02428 }
<a name="l02429"></a>02429 <span class="preprocessor">#endif  // FS_LEVEL_FEATURES</span>
<a name="l02430"></a>02430 <span class="preprocessor"></span>
<a name="l02431"></a>02431 
<a name="l02432"></a>02432 <span class="preprocessor">#if (FS_LEVEL_FEATURES &gt; FSFEATURE_READ)</span>
<a name="l02438"></a>02438 <span class="preprocessor">Bool  fat_update_fat2( void )</span>
<a name="l02439"></a><a class="code" href="a00021.html#8145cff91620fc1b70aa0eef5750db72">02439</a> <span class="preprocessor"></span>{
<a name="l02440"></a>02440   <span class="keywordflow">while</span>( <a class="code" href="a00020.html#b55b94c50b63cf8b83e2afcf2e0c2981" title="Offset (unit 512B) in fat of the first sector (unit 512B).">fs_g_u16_first_mod_fat</a> &lt;= <a class="code" href="a00020.html#e8c6fce6d75eb9ddbf1e63e46659e9cc" title="Offset (unit 512B) in fat of the last sector (unit 512B).">fs_g_u16_last_mod_fat</a> )
<a name="l02441"></a>02441   {
<a name="l02442"></a>02442      <span class="comment">// Compute the modification position of FAT 1</span>
<a name="l02443"></a>02443      <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> + <a class="code" href="a00020.html#b55b94c50b63cf8b83e2afcf2e0c2981" title="Offset (unit 512B) in fat of the first sector (unit 512B).">fs_g_u16_first_mod_fat</a>;
<a name="l02444"></a>02444      <span class="comment">// Read FAT1</span>
<a name="l02445"></a>02445       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( TRUE ))
<a name="l02446"></a>02446          <span class="keywordflow">return</span> FALSE;
<a name="l02447"></a>02447      <span class="comment">// Compute the modification position of FAT 2</span>
<a name="l02448"></a>02448      <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#af1d8fda28bded48a54c7eab4d729618" title="FAT address (unit 512B).">u32_ptr_fat</a> + ((U32)<a class="code" href="a00020.html#b55b94c50b63cf8b83e2afcf2e0c2981" title="Offset (unit 512B) in fat of the first sector (unit 512B).">fs_g_u16_first_mod_fat</a> + <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#68924ecf6935ab3e5a32dee9e5d61f7d" title="Size of one FAT (unit 512B).">u16_fat_size</a>);
<a name="l02449"></a>02449      <span class="comment">// Init the sector FAT2 with the previous sector of the FAT1</span>
<a name="l02450"></a>02450      <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( FALSE ))
<a name="l02451"></a>02451          <span class="keywordflow">return</span> FALSE;
<a name="l02452"></a>02452      <span class="comment">// Flag the sector FAT2 like modify</span>
<a name="l02453"></a>02453      <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l02454"></a>02454      <a class="code" href="a00020.html#b55b94c50b63cf8b83e2afcf2e0c2981" title="Offset (unit 512B) in fat of the first sector (unit 512B).">fs_g_u16_first_mod_fat</a>++;
<a name="l02455"></a>02455   }
<a name="l02456"></a>02456   <span class="keywordflow">return</span> TRUE;
<a name="l02457"></a>02457 }
<a name="l02458"></a>02458 <span class="preprocessor">#endif  // FS_LEVEL_FEATURES</span>
<a name="l02459"></a>02459 <span class="preprocessor"></span>
<a name="l02460"></a>02460 
<a name="l02461"></a>02461 <span class="preprocessor">#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES &amp; FSFEATURE_WRITE))</span>
<a name="l02473"></a>02473 <span class="preprocessor">Bool  fat_clear_cluster( void )</span>
<a name="l02474"></a><a class="code" href="a00021.html#6cc9ee9a14553be84990df27709f51a6">02474</a> <span class="preprocessor"></span>{
<a name="l02475"></a>02475    U8 u8_loop;
<a name="l02476"></a>02476 
<a name="l02477"></a>02477    <span class="comment">// Compute the cluster sector address</span>
<a name="l02478"></a>02478    <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#09c9847870bc2202980b54e38ea62fae" title="segment size (unit 512B), or position in cluster list (unit 512B)">u32_size_or_pos</a>  = 0;   <span class="comment">// Select the beginning of cluster</span>
<a name="l02479"></a>02479    <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#b08a718173c6b1a1966e6395801a32e7" title="This function gets or clears a cluster list.">fat_cluster_list</a>( <a class="code" href="a00020.html#b24c1ca2a8bc9c3e264eb923d3b90666">FS_CLUST_ACT_ONE</a>, FALSE ))
<a name="l02480"></a>02480       <span class="keywordflow">return</span> FALSE;
<a name="l02481"></a>02481 
<a name="l02482"></a>02482    <span class="comment">// Loop in the cluster (start at the end of cluster)</span>
<a name="l02483"></a>02483    <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a> = <a class="code" href="a00020.html#6d934f26f97b442c30712e57ee8b21e5" title="Variable frequently used by many function (optimization, no parameter in function)...">fs_g_seg</a>.<a class="code" href="a00009.html#da7b79119fecdfb1faab2512eb0ee172" title="segment address (unit 512B), or cluster number">u32_addr</a> + (<a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a> -1);
<a name="l02484"></a>02484    <span class="keywordflow">for</span>(  u8_loop = 0
<a name="l02485"></a>02485    ;     <a class="code" href="a00020.html#5c5e563664aa146853ff976ce0b412ec">fs_g_nav</a>.<a class="code" href="a00004.html#cddebea9972567fdcb5b87327b48125e" title="Cluster size (unit 512B).">u8_BPB_SecPerClus</a> != u8_loop
<a name="l02486"></a>02486    ;     u8_loop++ )
<a name="l02487"></a>02487    {
<a name="l02488"></a>02488       <span class="comment">// Update internal cache with cluster sector inforamtion but don't read data from memory</span>
<a name="l02489"></a>02489       <span class="keywordflow">if</span>( !<a class="code" href="a00019.html#a67dc439478853cefdd226f9c99c9539" title="This function loads a memory sector in internal cache sector.">fat_cache_read_sector</a>( FALSE ))
<a name="l02490"></a>02490          <span class="keywordflow">return</span> FALSE;
<a name="l02491"></a>02491 
<a name="l02492"></a>02492       <span class="keywordflow">if</span>(0 == u8_loop)
<a name="l02493"></a>02493       {  <span class="comment">// Clean internal cache (just for the sector)</span>
<a name="l02494"></a>02494          <a class="code" href="a00019.html#5948c1de515852418670d3fb8ae1e832" title="This function clears the sector cache.">fat_cache_clear</a>();
<a name="l02495"></a>02495       }
<a name="l02496"></a>02496       <a class="code" href="a00019.html#45c0f16885c9e414ddb4b5afaa1cde34" title="This function sets a flag to signal that sector cache is modified.">fat_cache_mark_sector_as_dirty</a>();
<a name="l02497"></a>02497       <a class="code" href="a00020.html#8e617688fc42b47e56cce053123fd05f" title="Store the address of futur cache (unit 512B).">fs_gu32_addrsector</a>--;         <span class="comment">// go to previous sector</span>
<a name="l02498"></a>02498    }
<a name="l02499"></a>02499    <span class="keywordflow">return</span> TRUE;
<a name="l02500"></a>02500 }
<a name="l02501"></a>02501 <span class="preprocessor">#endif  // FS_LEVEL_FEATURES</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Dec 21 18:30:55 2009 for AVR32 UC3 - FSACCESS Services by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
